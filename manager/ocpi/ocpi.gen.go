// Package ocpi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.4 DO NOT EDIT.

//lint:file-ignore * Ignore as this is generated

package ocpi

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

const (
	TokenScopes = "token.Scopes"
)

// Defines values for AuthorizationInfoAllowed.
const (
	AuthorizationInfoAllowedALLOWED    AuthorizationInfoAllowed = "ALLOWED"
	AuthorizationInfoAllowedBLOCKED    AuthorizationInfoAllowed = "BLOCKED"
	AuthorizationInfoAllowedEXPIRED    AuthorizationInfoAllowed = "EXPIRED"
	AuthorizationInfoAllowedNOCREDIT   AuthorizationInfoAllowed = "NO_CREDIT"
	AuthorizationInfoAllowedNOTALLOWED AuthorizationInfoAllowed = "NOT_ALLOWED"
)

// Defines values for CDRAuthMethod.
const (
	CDRAuthMethodAUTHREQUEST CDRAuthMethod = "AUTH_REQUEST"
	CDRAuthMethodCOMMAND     CDRAuthMethod = "COMMAND"
	CDRAuthMethodWHITELIST   CDRAuthMethod = "WHITELIST"
)

// Defines values for CdrDimensionType.
const (
	CdrDimensionTypeCURRENT         CdrDimensionType = "CURRENT"
	CdrDimensionTypeENERGY          CdrDimensionType = "ENERGY"
	CdrDimensionTypeENERGYEXPORT    CdrDimensionType = "ENERGY_EXPORT"
	CdrDimensionTypeENERGYIMPORT    CdrDimensionType = "ENERGY_IMPORT"
	CdrDimensionTypeMAXCURRENT      CdrDimensionType = "MAX_CURRENT"
	CdrDimensionTypeMAXPOWER        CdrDimensionType = "MAX_POWER"
	CdrDimensionTypeMINCURRENT      CdrDimensionType = "MIN_CURRENT"
	CdrDimensionTypeMINPOWER        CdrDimensionType = "MIN_POWER"
	CdrDimensionTypePARKINGTIME     CdrDimensionType = "PARKING_TIME"
	CdrDimensionTypePOWER           CdrDimensionType = "POWER"
	CdrDimensionTypeRESERVATIONTIME CdrDimensionType = "RESERVATION_TIME"
	CdrDimensionTypeSTATEOFCHARGE   CdrDimensionType = "STATE_OF_CHARGE"
	CdrDimensionTypeTIME            CdrDimensionType = "TIME"
)

// Defines values for CdrLocationConnectorFormat.
const (
	CdrLocationConnectorFormatCABLE  CdrLocationConnectorFormat = "CABLE"
	CdrLocationConnectorFormatSOCKET CdrLocationConnectorFormat = "SOCKET"
)

// Defines values for CdrLocationConnectorPowerType.
const (
	CdrLocationConnectorPowerTypeAC1PHASE CdrLocationConnectorPowerType = "AC_1_PHASE"
	CdrLocationConnectorPowerTypeAC3PHASE CdrLocationConnectorPowerType = "AC_3_PHASE"
	CdrLocationConnectorPowerTypeDC       CdrLocationConnectorPowerType = "DC"
)

// Defines values for CdrLocationConnectorStandard.
const (
	CdrLocationConnectorStandardCHADEMO            CdrLocationConnectorStandard = "CHADEMO"
	CdrLocationConnectorStandardDOMESTICA          CdrLocationConnectorStandard = "DOMESTIC_A"
	CdrLocationConnectorStandardDOMESTICB          CdrLocationConnectorStandard = "DOMESTIC_B"
	CdrLocationConnectorStandardDOMESTICC          CdrLocationConnectorStandard = "DOMESTIC_C"
	CdrLocationConnectorStandardDOMESTICD          CdrLocationConnectorStandard = "DOMESTIC_D"
	CdrLocationConnectorStandardDOMESTICE          CdrLocationConnectorStandard = "DOMESTIC_E"
	CdrLocationConnectorStandardDOMESTICF          CdrLocationConnectorStandard = "DOMESTIC_F"
	CdrLocationConnectorStandardDOMESTICG          CdrLocationConnectorStandard = "DOMESTIC_G"
	CdrLocationConnectorStandardDOMESTICH          CdrLocationConnectorStandard = "DOMESTIC_H"
	CdrLocationConnectorStandardDOMESTICI          CdrLocationConnectorStandard = "DOMESTIC_I"
	CdrLocationConnectorStandardDOMESTICJ          CdrLocationConnectorStandard = "DOMESTIC_J"
	CdrLocationConnectorStandardDOMESTICK          CdrLocationConnectorStandard = "DOMESTIC_K"
	CdrLocationConnectorStandardDOMESTICL          CdrLocationConnectorStandard = "DOMESTIC_L"
	CdrLocationConnectorStandardIEC603092Single16  CdrLocationConnectorStandard = "IEC_60309_2_single_16"
	CdrLocationConnectorStandardIEC603092Three16   CdrLocationConnectorStandard = "IEC_60309_2_three_16"
	CdrLocationConnectorStandardIEC603092Three32   CdrLocationConnectorStandard = "IEC_60309_2_three_32"
	CdrLocationConnectorStandardIEC603092Three64   CdrLocationConnectorStandard = "IEC_60309_2_three_64"
	CdrLocationConnectorStandardIEC62196T1         CdrLocationConnectorStandard = "IEC_62196_T1"
	CdrLocationConnectorStandardIEC62196T1COMBO    CdrLocationConnectorStandard = "IEC_62196_T1_COMBO"
	CdrLocationConnectorStandardIEC62196T2         CdrLocationConnectorStandard = "IEC_62196_T2"
	CdrLocationConnectorStandardIEC62196T2COMBO    CdrLocationConnectorStandard = "IEC_62196_T2_COMBO"
	CdrLocationConnectorStandardIEC62196T3A        CdrLocationConnectorStandard = "IEC_62196_T3A"
	CdrLocationConnectorStandardIEC62196T3C        CdrLocationConnectorStandard = "IEC_62196_T3C"
	CdrLocationConnectorStandardPANTOGRAPHBOTTOMUP CdrLocationConnectorStandard = "PANTOGRAPH_BOTTOM_UP"
	CdrLocationConnectorStandardPANTOGRAPHTOPDOWN  CdrLocationConnectorStandard = "PANTOGRAPH_TOP_DOWN"
	CdrLocationConnectorStandardTESLAR             CdrLocationConnectorStandard = "TESLA_R"
	CdrLocationConnectorStandardTESLAS             CdrLocationConnectorStandard = "TESLA_S"
)

// Defines values for CdrTokenType.
const (
	CdrTokenTypeADHOCUSER CdrTokenType = "AD_HOC_USER"
	CdrTokenTypeAPPUSER   CdrTokenType = "APP_USER"
	CdrTokenTypeOTHER     CdrTokenType = "OTHER"
	CdrTokenTypeRFID      CdrTokenType = "RFID"
)

// Defines values for ChargingPreferencesProfileType.
const (
	ChargingPreferencesProfileTypeCHEAP   ChargingPreferencesProfileType = "CHEAP"
	ChargingPreferencesProfileTypeFAST    ChargingPreferencesProfileType = "FAST"
	ChargingPreferencesProfileTypeGREEN   ChargingPreferencesProfileType = "GREEN"
	ChargingPreferencesProfileTypeREGULAR ChargingPreferencesProfileType = "REGULAR"
)

// Defines values for ChargingProfileChargingRateUnit.
const (
	A ChargingProfileChargingRateUnit = "A"
	W ChargingProfileChargingRateUnit = "W"
)

// Defines values for ChargingProfileResponseResult.
const (
	ChargingProfileResponseResultACCEPTED       ChargingProfileResponseResult = "ACCEPTED"
	ChargingProfileResponseResultNOTSUPPORTED   ChargingProfileResponseResult = "NOT_SUPPORTED"
	ChargingProfileResponseResultREJECTED       ChargingProfileResponseResult = "REJECTED"
	ChargingProfileResponseResultTOOOFTEN       ChargingProfileResponseResult = "TOO_OFTEN"
	ChargingProfileResponseResultUNKNOWNSESSION ChargingProfileResponseResult = "UNKNOWN_SESSION"
)

// Defines values for CommandResponseResult.
const (
	CommandResponseResultACCEPTED       CommandResponseResult = "ACCEPTED"
	CommandResponseResultNOTSUPPORTED   CommandResponseResult = "NOT_SUPPORTED"
	CommandResponseResultREJECTED       CommandResponseResult = "REJECTED"
	CommandResponseResultUNKNOWNSESSION CommandResponseResult = "UNKNOWN_SESSION"
)

// Defines values for CommandResultResult.
const (
	CommandResultResultACCEPTED            CommandResultResult = "ACCEPTED"
	CommandResultResultCANCELEDRESERVATION CommandResultResult = "CANCELED_RESERVATION"
	CommandResultResultEVSEINOPERATIVE     CommandResultResult = "EVSE_INOPERATIVE"
	CommandResultResultEVSEOCCUPIED        CommandResultResult = "EVSE_OCCUPIED"
	CommandResultResultFAILED              CommandResultResult = "FAILED"
	CommandResultResultNOTSUPPORTED        CommandResultResult = "NOT_SUPPORTED"
	CommandResultResultREJECTED            CommandResultResult = "REJECTED"
	CommandResultResultTIMEOUT             CommandResultResult = "TIMEOUT"
	CommandResultResultUNKNOWNRESERVATION  CommandResultResult = "UNKNOWN_RESERVATION"
)

// Defines values for ConnectorFormat.
const (
	ConnectorFormatCABLE  ConnectorFormat = "CABLE"
	ConnectorFormatSOCKET ConnectorFormat = "SOCKET"
)

// Defines values for ConnectorPowerType.
const (
	ConnectorPowerTypeAC1PHASE ConnectorPowerType = "AC_1_PHASE"
	ConnectorPowerTypeAC3PHASE ConnectorPowerType = "AC_3_PHASE"
	ConnectorPowerTypeDC       ConnectorPowerType = "DC"
)

// Defines values for ConnectorStandard.
const (
	ConnectorStandardCHADEMO            ConnectorStandard = "CHADEMO"
	ConnectorStandardCHAOJI             ConnectorStandard = "CHAOJI"
	ConnectorStandardDOMESTICA          ConnectorStandard = "DOMESTIC_A"
	ConnectorStandardDOMESTICB          ConnectorStandard = "DOMESTIC_B"
	ConnectorStandardDOMESTICC          ConnectorStandard = "DOMESTIC_C"
	ConnectorStandardDOMESTICD          ConnectorStandard = "DOMESTIC_D"
	ConnectorStandardDOMESTICE          ConnectorStandard = "DOMESTIC_E"
	ConnectorStandardDOMESTICF          ConnectorStandard = "DOMESTIC_F"
	ConnectorStandardDOMESTICG          ConnectorStandard = "DOMESTIC_G"
	ConnectorStandardDOMESTICH          ConnectorStandard = "DOMESTIC_H"
	ConnectorStandardDOMESTICI          ConnectorStandard = "DOMESTIC_I"
	ConnectorStandardDOMESTICJ          ConnectorStandard = "DOMESTIC_J"
	ConnectorStandardDOMESTICK          ConnectorStandard = "DOMESTIC_K"
	ConnectorStandardDOMESTICL          ConnectorStandard = "DOMESTIC_L"
	ConnectorStandardGBTAC              ConnectorStandard = "GBT_AC"
	ConnectorStandardGBTDC              ConnectorStandard = "GBT_DC"
	ConnectorStandardIEC603092Single16  ConnectorStandard = "IEC_60309_2_single_16"
	ConnectorStandardIEC603092Three16   ConnectorStandard = "IEC_60309_2_three_16"
	ConnectorStandardIEC603092Three32   ConnectorStandard = "IEC_60309_2_three_32"
	ConnectorStandardIEC603092Three64   ConnectorStandard = "IEC_60309_2_three_64"
	ConnectorStandardIEC62196T1         ConnectorStandard = "IEC_62196_T1"
	ConnectorStandardIEC62196T1COMBO    ConnectorStandard = "IEC_62196_T1_COMBO"
	ConnectorStandardIEC62196T2         ConnectorStandard = "IEC_62196_T2"
	ConnectorStandardIEC62196T2COMBO    ConnectorStandard = "IEC_62196_T2_COMBO"
	ConnectorStandardIEC62196T3A        ConnectorStandard = "IEC_62196_T3A"
	ConnectorStandardIEC62196T3C        ConnectorStandard = "IEC_62196_T3C"
	ConnectorStandardNEMA1030           ConnectorStandard = "NEMA_10_30"
	ConnectorStandardNEMA1050           ConnectorStandard = "NEMA_10_50"
	ConnectorStandardNEMA1430           ConnectorStandard = "NEMA_14_30"
	ConnectorStandardNEMA1450           ConnectorStandard = "NEMA_14_50"
	ConnectorStandardNEMA520            ConnectorStandard = "NEMA_5_20"
	ConnectorStandardNEMA630            ConnectorStandard = "NEMA_6_30"
	ConnectorStandardNEMA650            ConnectorStandard = "NEMA_6_50"
	ConnectorStandardPANTOGRAPHBOTTOMUP ConnectorStandard = "PANTOGRAPH_BOTTOM_UP"
	ConnectorStandardPANTOGRAPHTOPDOWN  ConnectorStandard = "PANTOGRAPH_TOP_DOWN"
	ConnectorStandardTESLAR             ConnectorStandard = "TESLA_R"
	ConnectorStandardTESLAS             ConnectorStandard = "TESLA_S"
	ConnectorStandardUNKNOWN            ConnectorStandard = "UNKNOWN"
)

// Defines values for CredentialsRoleRole.
const (
	CredentialsRoleRoleCPO   CredentialsRoleRole = "CPO"
	CredentialsRoleRoleEMSP  CredentialsRoleRole = "EMSP"
	CredentialsRoleRoleHUB   CredentialsRoleRole = "HUB"
	CredentialsRoleRoleNAP   CredentialsRoleRole = "NAP"
	CredentialsRoleRoleNSP   CredentialsRoleRole = "NSP"
	CredentialsRoleRoleOTHER CredentialsRoleRole = "OTHER"
	CredentialsRoleRoleSCSP  CredentialsRoleRole = "SCSP"
)

// Defines values for EndpointRole.
const (
	RECEIVER EndpointRole = "RECEIVER"
	SENDER   EndpointRole = "SENDER"
)

// Defines values for EnergySourceSource.
const (
	COAL          EnergySourceSource = "COAL"
	GAS           EnergySourceSource = "GAS"
	GENERALFOSSIL EnergySourceSource = "GENERAL_FOSSIL"
	GENERALGREEN  EnergySourceSource = "GENERAL_GREEN"
	NUCLEAR       EnergySourceSource = "NUCLEAR"
	SOLAR         EnergySourceSource = "SOLAR"
	WATER         EnergySourceSource = "WATER"
	WIND          EnergySourceSource = "WIND"
)

// Defines values for EnvironmentalImpactCategory.
const (
	CARBONDIOXIDE EnvironmentalImpactCategory = "CARBON_DIOXIDE"
	NUCLEARWASTE  EnvironmentalImpactCategory = "NUCLEAR_WASTE"
)

// Defines values for EvseCapabilities.
const (
	CHARGINGPREFERENCESCAPABLE EvseCapabilities = "CHARGING_PREFERENCES_CAPABLE"
	CHARGINGPROFILECAPABLE     EvseCapabilities = "CHARGING_PROFILE_CAPABLE"
	CHIPCARDSUPPORT            EvseCapabilities = "CHIP_CARD_SUPPORT"
	CONTACTLESSCARDSUPPORT     EvseCapabilities = "CONTACTLESS_CARD_SUPPORT"
	CREDITCARDPAYABLE          EvseCapabilities = "CREDIT_CARD_PAYABLE"
	DEBITCARDPAYABLE           EvseCapabilities = "DEBIT_CARD_PAYABLE"
	PEDTERMINAL                EvseCapabilities = "PED_TERMINAL"
	REMOTESTARTSTOPCAPABLE     EvseCapabilities = "REMOTE_START_STOP_CAPABLE"
	RESERVABLE                 EvseCapabilities = "RESERVABLE"
	RFIDREADER                 EvseCapabilities = "RFID_READER"
	TOKENGROUPCAPABLE          EvseCapabilities = "TOKEN_GROUP_CAPABLE"
	UNLOCKCAPABLE              EvseCapabilities = "UNLOCK_CAPABLE"
)

// Defines values for EvseParkingRestrictions.
const (
	CUSTOMERS   EvseParkingRestrictions = "CUSTOMERS"
	DISABLED    EvseParkingRestrictions = "DISABLED"
	EVONLY      EvseParkingRestrictions = "EV_ONLY"
	MOTORCYCLES EvseParkingRestrictions = "MOTORCYCLES"
	PLUGGED     EvseParkingRestrictions = "PLUGGED"
)

// Defines values for EvseStatus.
const (
	EvseStatusAVAILABLE   EvseStatus = "AVAILABLE"
	EvseStatusBLOCKED     EvseStatus = "BLOCKED"
	EvseStatusCHARGING    EvseStatus = "CHARGING"
	EvseStatusINOPERATIVE EvseStatus = "INOPERATIVE"
	EvseStatusOUTOFORDER  EvseStatus = "OUTOFORDER"
	EvseStatusPLANNED     EvseStatus = "PLANNED"
	EvseStatusREMOVED     EvseStatus = "REMOVED"
	EvseStatusRESERVED    EvseStatus = "RESERVED"
	EvseStatusUNKNOWN     EvseStatus = "UNKNOWN"
)

// Defines values for GenericChargingProfileResultResult.
const (
	GenericChargingProfileResultResultACCEPTED GenericChargingProfileResultResult = "ACCEPTED"
	GenericChargingProfileResultResultREJECTED GenericChargingProfileResultResult = "REJECTED"
	GenericChargingProfileResultResultUNKNOWN  GenericChargingProfileResultResult = "UNKNOWN"
)

// Defines values for ImageCategory.
const (
	ImageCategoryCHARGER  ImageCategory = "CHARGER"
	ImageCategoryENTRANCE ImageCategory = "ENTRANCE"
	ImageCategoryLOCATION ImageCategory = "LOCATION"
	ImageCategoryNETWORK  ImageCategory = "NETWORK"
	ImageCategoryOPERATOR ImageCategory = "OPERATOR"
	ImageCategoryOTHER    ImageCategory = "OTHER"
	ImageCategoryOWNER    ImageCategory = "OWNER"
)

// Defines values for LocationFacilities.
const (
	LocationFacilitiesAIRPORT        LocationFacilities = "AIRPORT"
	LocationFacilitiesBIKESHARING    LocationFacilities = "BIKE_SHARING"
	LocationFacilitiesBUSSTOP        LocationFacilities = "BUS_STOP"
	LocationFacilitiesCAFE           LocationFacilities = "CAFE"
	LocationFacilitiesCARPOOLPARKING LocationFacilities = "CARPOOL_PARKING"
	LocationFacilitiesFUELSTATION    LocationFacilities = "FUEL_STATION"
	LocationFacilitiesHOTEL          LocationFacilities = "HOTEL"
	LocationFacilitiesMALL           LocationFacilities = "MALL"
	LocationFacilitiesMETROSTATION   LocationFacilities = "METRO_STATION"
	LocationFacilitiesMUSEUM         LocationFacilities = "MUSEUM"
	LocationFacilitiesNATURE         LocationFacilities = "NATURE"
	LocationFacilitiesPARKINGLOT     LocationFacilities = "PARKING_LOT"
	LocationFacilitiesRECREATIONAREA LocationFacilities = "RECREATION_AREA"
	LocationFacilitiesRESTAURANT     LocationFacilities = "RESTAURANT"
	LocationFacilitiesSPORT          LocationFacilities = "SPORT"
	LocationFacilitiesSUPERMARKET    LocationFacilities = "SUPERMARKET"
	LocationFacilitiesTAXISTAND      LocationFacilities = "TAXI_STAND"
	LocationFacilitiesTRAINSTATION   LocationFacilities = "TRAIN_STATION"
	LocationFacilitiesTRAMSTOP       LocationFacilities = "TRAM_STOP"
	LocationFacilitiesWIFI           LocationFacilities = "WIFI"
)

// Defines values for LocationParkingType.
const (
	LocationParkingTypeALONGMOTORWAY     LocationParkingType = "ALONG_MOTORWAY"
	LocationParkingTypeONDRIVEWAY        LocationParkingType = "ON_DRIVEWAY"
	LocationParkingTypeONSTREET          LocationParkingType = "ON_STREET"
	LocationParkingTypePARKINGGARAGE     LocationParkingType = "PARKING_GARAGE"
	LocationParkingTypePARKINGLOT        LocationParkingType = "PARKING_LOT"
	LocationParkingTypeUNDERGROUNDGARAGE LocationParkingType = "UNDERGROUND_GARAGE"
)

// Defines values for OcpiResponseChargingPreferencesResponseData.
const (
	ACCEPTED                OcpiResponseChargingPreferencesResponseData = "ACCEPTED"
	DEPARTUREREQUIRED       OcpiResponseChargingPreferencesResponseData = "DEPARTURE_REQUIRED"
	ENERGYNEEDREQUIRED      OcpiResponseChargingPreferencesResponseData = "ENERGY_NEED_REQUIRED"
	NOTPOSSIBLE             OcpiResponseChargingPreferencesResponseData = "NOT_POSSIBLE"
	PROFILETYPENOTSUPPORTED OcpiResponseChargingPreferencesResponseData = "PROFILE_TYPE_NOT_SUPPORTED"
)

// Defines values for PriceComponentType.
const (
	PriceComponentTypeENERGY      PriceComponentType = "ENERGY"
	PriceComponentTypeFLAT        PriceComponentType = "FLAT"
	PriceComponentTypePARKINGTIME PriceComponentType = "PARKING_TIME"
	PriceComponentTypeTIME        PriceComponentType = "TIME"
)

// Defines values for PublishTokenTypeType.
const (
	PublishTokenTypeTypeADHOCUSER PublishTokenTypeType = "AD_HOC_USER"
	PublishTokenTypeTypeAPPUSER   PublishTokenTypeType = "APP_USER"
	PublishTokenTypeTypeOTHER     PublishTokenTypeType = "OTHER"
	PublishTokenTypeTypeRFID      PublishTokenTypeType = "RFID"
)

// Defines values for SessionAuthMethod.
const (
	SessionAuthMethodAUTHREQUEST SessionAuthMethod = "AUTH_REQUEST"
	SessionAuthMethodCOMMAND     SessionAuthMethod = "COMMAND"
	SessionAuthMethodWHITELIST   SessionAuthMethod = "WHITELIST"
)

// Defines values for SessionStatus.
const (
	SessionStatusACTIVE      SessionStatus = "ACTIVE"
	SessionStatusCOMPLETED   SessionStatus = "COMPLETED"
	SessionStatusINVALID     SessionStatus = "INVALID"
	SessionStatusPENDING     SessionStatus = "PENDING"
	SessionStatusRESERVATION SessionStatus = "RESERVATION"
)

// Defines values for StatusScheduleStatus.
const (
	AVAILABLE   StatusScheduleStatus = "AVAILABLE"
	BLOCKED     StatusScheduleStatus = "BLOCKED"
	CHARGING    StatusScheduleStatus = "CHARGING"
	INOPERATIVE StatusScheduleStatus = "INOPERATIVE"
	OUTOFORDER  StatusScheduleStatus = "OUTOFORDER"
	PLANNED     StatusScheduleStatus = "PLANNED"
	REMOVED     StatusScheduleStatus = "REMOVED"
	RESERVED    StatusScheduleStatus = "RESERVED"
	UNKNOWN     StatusScheduleStatus = "UNKNOWN"
)

// Defines values for TariffType.
const (
	TariffTypeADHOCPAYMENT TariffType = "AD_HOC_PAYMENT"
	TariffTypePROFILECHEAP TariffType = "PROFILE_CHEAP"
	TariffTypePROFILEFAST  TariffType = "PROFILE_FAST"
	TariffTypePROFILEGREEN TariffType = "PROFILE_GREEN"
	TariffTypeREGULAR      TariffType = "REGULAR"
)

// Defines values for TariffRestrictionsDayOfWeek.
const (
	FRIDAY    TariffRestrictionsDayOfWeek = "FRIDAY"
	MONDAY    TariffRestrictionsDayOfWeek = "MONDAY"
	SATURDAY  TariffRestrictionsDayOfWeek = "SATURDAY"
	SUNDAY    TariffRestrictionsDayOfWeek = "SUNDAY"
	THURSDAY  TariffRestrictionsDayOfWeek = "THURSDAY"
	TUESDAY   TariffRestrictionsDayOfWeek = "TUESDAY"
	WEDNESDAY TariffRestrictionsDayOfWeek = "WEDNESDAY"
)

// Defines values for TariffRestrictionsReservation.
const (
	TariffRestrictionsReservationRESERVATION        TariffRestrictionsReservation = "RESERVATION"
	TariffRestrictionsReservationRESERVATIONEXPIRES TariffRestrictionsReservation = "RESERVATION_EXPIRES"
)

// Defines values for TokenDefaultProfileType.
const (
	CHEAP   TokenDefaultProfileType = "CHEAP"
	FAST    TokenDefaultProfileType = "FAST"
	GREEN   TokenDefaultProfileType = "GREEN"
	REGULAR TokenDefaultProfileType = "REGULAR"
)

// Defines values for TokenType.
const (
	TokenTypeADHOCUSER TokenType = "AD_HOC_USER"
	TokenTypeAPPUSER   TokenType = "APP_USER"
	TokenTypeOTHER     TokenType = "OTHER"
	TokenTypeRFID      TokenType = "RFID"
)

// Defines values for TokenWhitelist.
const (
	ALLOWED        TokenWhitelist = "ALLOWED"
	ALLOWEDOFFLINE TokenWhitelist = "ALLOWED_OFFLINE"
	ALWAYS         TokenWhitelist = "ALWAYS"
	NEVER          TokenWhitelist = "NEVER"
)

// Defines values for GetClientOwnedTokenParamsType.
const (
	GetClientOwnedTokenParamsTypeADHOCUSER GetClientOwnedTokenParamsType = "AD_HOC_USER"
	GetClientOwnedTokenParamsTypeAPPUSER   GetClientOwnedTokenParamsType = "APP_USER"
	GetClientOwnedTokenParamsTypeOTHER     GetClientOwnedTokenParamsType = "OTHER"
	GetClientOwnedTokenParamsTypeRFID      GetClientOwnedTokenParamsType = "RFID"
)

// Defines values for PatchClientOwnedTokenParamsType.
const (
	PatchClientOwnedTokenParamsTypeADHOCUSER PatchClientOwnedTokenParamsType = "AD_HOC_USER"
	PatchClientOwnedTokenParamsTypeAPPUSER   PatchClientOwnedTokenParamsType = "APP_USER"
	PatchClientOwnedTokenParamsTypeOTHER     PatchClientOwnedTokenParamsType = "OTHER"
	PatchClientOwnedTokenParamsTypeRFID      PatchClientOwnedTokenParamsType = "RFID"
)

// Defines values for PutClientOwnedTokenParamsType.
const (
	PutClientOwnedTokenParamsTypeADHOCUSER PutClientOwnedTokenParamsType = "AD_HOC_USER"
	PutClientOwnedTokenParamsTypeAPPUSER   PutClientOwnedTokenParamsType = "APP_USER"
	PutClientOwnedTokenParamsTypeOTHER     PutClientOwnedTokenParamsType = "OTHER"
	PutClientOwnedTokenParamsTypeRFID      PutClientOwnedTokenParamsType = "RFID"
)

// Defines values for PostAsyncResponseParamsCommand.
const (
	CANCELRESERVATION PostAsyncResponseParamsCommand = "CANCEL_RESERVATION"
	RESERVENOW        PostAsyncResponseParamsCommand = "RESERVE_NOW"
	STARTSESSION      PostAsyncResponseParamsCommand = "START_SESSION"
	STOPSESSION       PostAsyncResponseParamsCommand = "STOP_SESSION"
	UNLOCKCONNECTOR   PostAsyncResponseParamsCommand = "UNLOCK_CONNECTOR"
)

// Defines values for PostRealTimeTokenAuthorizationParamsType.
const (
	ADHOCUSER PostRealTimeTokenAuthorizationParamsType = "AD_HOC_USER"
	APPUSER   PostRealTimeTokenAuthorizationParamsType = "APP_USER"
	OTHER     PostRealTimeTokenAuthorizationParamsType = "OTHER"
	RFID      PostRealTimeTokenAuthorizationParamsType = "RFID"
)

// ActiveChargingProfile defines model for ActiveChargingProfile.
type ActiveChargingProfile struct {
	ChargingProfile ChargingProfile `json:"charging_profile"`
	StartDateTime   string          `json:"start_date_time"`
}

// AdditionalGeoLocation defines model for AdditionalGeoLocation.
type AdditionalGeoLocation struct {
	Latitude  string       `json:"latitude"`
	Longitude string       `json:"longitude"`
	Name      *DisplayText `json:"name,omitempty"`
}

// AuthorizationInfo defines model for AuthorizationInfo.
type AuthorizationInfo struct {
	Allowed                AuthorizationInfoAllowed `json:"allowed"`
	AuthorizationReference *string                  `json:"authorization_reference,omitempty"`
	Info                   *DisplayText             `json:"info,omitempty"`
	Location               *LocationReferences      `json:"location,omitempty"`
	Token                  Token                    `json:"token"`
}

// AuthorizationInfoAllowed defines model for AuthorizationInfo.Allowed.
type AuthorizationInfoAllowed string

// BusinessDetails defines model for BusinessDetails.
type BusinessDetails struct {
	Logo    *Image  `json:"logo,omitempty"`
	Name    string  `json:"name"`
	Website *string `json:"website,omitempty"`
}

// CDR defines model for CDR.
type CDR struct {
	AuthMethod             CDRAuthMethod    `json:"auth_method"`
	AuthorizationReference *string          `json:"authorization_reference,omitempty"`
	CdrLocation            CdrLocation      `json:"cdr_location"`
	CdrToken               CdrToken         `json:"cdr_token"`
	ChargingPeriods        []ChargingPeriod `json:"charging_periods"`
	CountryCode            string           `json:"country_code"`
	Credit                 *bool            `json:"credit,omitempty"`
	CreditReferenceId      *string          `json:"credit_reference_id,omitempty"`
	Currency               string           `json:"currency"`
	EndDateTime            string           `json:"end_date_time"`
	Id                     string           `json:"id"`
	InvoiceReferenceId     *string          `json:"invoice_reference_id,omitempty"`
	LastUpdated            string           `json:"last_updated"`
	MeterId                *string          `json:"meter_id,omitempty"`
	PartyId                string           `json:"party_id"`
	Remark                 *string          `json:"remark,omitempty"`
	SessionId              *string          `json:"session_id,omitempty"`
	SignedData             *SignedData      `json:"signed_data,omitempty"`
	StartDateTime          string           `json:"start_date_time"`
	Tariffs                *[]Tariff        `json:"tariffs,omitempty"`
	TotalCost              Price            `json:"total_cost"`
	TotalEnergy            float32          `json:"total_energy"`
	TotalEnergyCost        *Price           `json:"total_energy_cost,omitempty"`
	TotalFixedCost         *Price           `json:"total_fixed_cost,omitempty"`
	TotalParkingCost       *Price           `json:"total_parking_cost,omitempty"`
	TotalParkingTime       *float32         `json:"total_parking_time,omitempty"`
	TotalReservationCost   *Price           `json:"total_reservation_cost,omitempty"`
	TotalTime              float32          `json:"total_time"`
	TotalTimeCost          *Price           `json:"total_time_cost,omitempty"`
}

// CDRAuthMethod defines model for CDR.AuthMethod.
type CDRAuthMethod string

// CancelReservation defines model for CancelReservation.
type CancelReservation struct {
	ReservationId string `json:"reservation_id"`
	ResponseUrl   string `json:"response_url"`
}

// CdrDimension defines model for CdrDimension.
type CdrDimension struct {
	Type   CdrDimensionType `json:"type"`
	Volume float32          `json:"volume"`
}

// CdrDimensionType defines model for CdrDimension.Type.
type CdrDimensionType string

// CdrLocation defines model for CdrLocation.
type CdrLocation struct {
	Address            string                        `json:"address"`
	City               string                        `json:"city"`
	ConnectorFormat    CdrLocationConnectorFormat    `json:"connector_format"`
	ConnectorId        string                        `json:"connector_id"`
	ConnectorPowerType CdrLocationConnectorPowerType `json:"connector_power_type"`
	ConnectorStandard  CdrLocationConnectorStandard  `json:"connector_standard"`
	Coordinates        GeoLocation                   `json:"coordinates"`
	Country            string                        `json:"country"`
	EvseId             string                        `json:"evse_id"`
	EvseUid            string                        `json:"evse_uid"`
	Id                 string                        `json:"id"`
	Name               *string                       `json:"name,omitempty"`
	PostalCode         string                        `json:"postal_code"`
}

// CdrLocationConnectorFormat defines model for CdrLocation.ConnectorFormat.
type CdrLocationConnectorFormat string

// CdrLocationConnectorPowerType defines model for CdrLocation.ConnectorPowerType.
type CdrLocationConnectorPowerType string

// CdrLocationConnectorStandard defines model for CdrLocation.ConnectorStandard.
type CdrLocationConnectorStandard string

// CdrToken defines model for CdrToken.
type CdrToken struct {
	ContractId string       `json:"contract_id"`
	Type       CdrTokenType `json:"type"`
	Uid        string       `json:"uid"`
}

// CdrTokenType defines model for CdrToken.Type.
type CdrTokenType string

// ChargingPeriod defines model for ChargingPeriod.
type ChargingPeriod struct {
	Dimensions    []CdrDimension `json:"dimensions"`
	StartDateTime string         `json:"start_date_time"`
	TariffId      *string        `json:"tariff_id,omitempty"`
}

// ChargingPreferences defines model for ChargingPreferences.
type ChargingPreferences struct {
	DepartureTime    *string                        `json:"departure_time,omitempty"`
	DischargeAllowed *bool                          `json:"discharge_allowed,omitempty"`
	EnergyNeed       *float32                       `json:"energy_need,omitempty"`
	ProfileType      ChargingPreferencesProfileType `json:"profile_type"`
}

// ChargingPreferencesProfileType defines model for ChargingPreferences.ProfileType.
type ChargingPreferencesProfileType string

// ChargingProfile defines model for ChargingProfile.
type ChargingProfile struct {
	ChargingProfilePeriod *[]ChargingProfilePeriod        `json:"charging_profile_period,omitempty"`
	ChargingRateUnit      ChargingProfileChargingRateUnit `json:"charging_rate_unit"`
	Duration              *int32                          `json:"duration,omitempty"`
	MinChargingRate       *float32                        `json:"min_charging_rate,omitempty"`
	StartDateTime         *string                         `json:"start_date_time,omitempty"`
}

// ChargingProfileChargingRateUnit defines model for ChargingProfile.ChargingRateUnit.
type ChargingProfileChargingRateUnit string

// ChargingProfilePeriod defines model for ChargingProfilePeriod.
type ChargingProfilePeriod struct {
	Limit       float32 `json:"limit"`
	StartPeriod int32   `json:"start_period"`
}

// ChargingProfileResponse defines model for ChargingProfileResponse.
type ChargingProfileResponse struct {
	Result  ChargingProfileResponseResult `json:"result"`
	Timeout int32                         `json:"timeout"`
}

// ChargingProfileResponseResult defines model for ChargingProfileResponse.Result.
type ChargingProfileResponseResult string

// CommandResponse defines model for CommandResponse.
type CommandResponse struct {
	Message *DisplayText          `json:"message,omitempty"`
	Result  CommandResponseResult `json:"result"`
	Timeout int32                 `json:"timeout"`
}

// CommandResponseResult defines model for CommandResponse.Result.
type CommandResponseResult string

// CommandResult defines model for CommandResult.
type CommandResult struct {
	Message *DisplayText        `json:"message,omitempty"`
	Result  CommandResultResult `json:"result"`
}

// CommandResultResult defines model for CommandResult.Result.
type CommandResultResult string

// Connector defines model for Connector.
type Connector struct {
	Format             ConnectorFormat    `json:"format"`
	Id                 string             `json:"id"`
	LastUpdated        string             `json:"last_updated"`
	MaxAmperage        int32              `json:"max_amperage"`
	MaxElectricPower   *int32             `json:"max_electric_power,omitempty"`
	MaxVoltage         int32              `json:"max_voltage"`
	PowerType          ConnectorPowerType `json:"power_type"`
	Standard           ConnectorStandard  `json:"standard"`
	TariffIds          *[]string          `json:"tariff_ids,omitempty"`
	TermsAndConditions *string            `json:"terms_and_conditions,omitempty"`
}

// ConnectorFormat defines model for Connector.Format.
type ConnectorFormat string

// ConnectorPowerType defines model for Connector.PowerType.
type ConnectorPowerType string

// ConnectorStandard defines model for Connector.Standard.
type ConnectorStandard string

// Credentials defines model for Credentials.
type Credentials struct {
	Roles []CredentialsRole `json:"roles"`
	Token string            `json:"token"`
	Url   string            `json:"url"`
}

// CredentialsRole defines model for CredentialsRole.
type CredentialsRole struct {
	BusinessDetails BusinessDetails     `json:"business_details"`
	CountryCode     string              `json:"country_code"`
	PartyId         string              `json:"party_id"`
	Role            CredentialsRoleRole `json:"role"`
}

// CredentialsRoleRole defines model for CredentialsRole.Role.
type CredentialsRoleRole string

// DisplayText defines model for DisplayText.
type DisplayText struct {
	Language string `json:"language"`
	Text     string `json:"text"`
}

// Endpoint defines model for Endpoint.
type Endpoint struct {
	Identifier string       `json:"identifier"`
	Role       EndpointRole `json:"role"`
	Url        string       `json:"url"`
}

// EndpointRole defines model for Endpoint.Role.
type EndpointRole string

// EnergyContract defines model for EnergyContract.
type EnergyContract struct {
	ContractId   *string `json:"contract_id,omitempty"`
	SupplierName string  `json:"supplier_name"`
}

// EnergyMix defines model for EnergyMix.
type EnergyMix struct {
	EnergyProductName *string                `json:"energy_product_name,omitempty"`
	EnergySources     *[]EnergySource        `json:"energy_sources,omitempty"`
	EnvironImpact     *[]EnvironmentalImpact `json:"environ_impact,omitempty"`
	IsGreenEnergy     bool                   `json:"is_green_energy"`
	SupplierName      *string                `json:"supplier_name,omitempty"`
}

// EnergySource defines model for EnergySource.
type EnergySource struct {
	Percentage float32            `json:"percentage"`
	Source     EnergySourceSource `json:"source"`
}

// EnergySourceSource defines model for EnergySource.Source.
type EnergySourceSource string

// EnvironmentalImpact defines model for EnvironmentalImpact.
type EnvironmentalImpact struct {
	Amount   float32                     `json:"amount"`
	Category EnvironmentalImpactCategory `json:"category"`
}

// EnvironmentalImpactCategory defines model for EnvironmentalImpact.Category.
type EnvironmentalImpactCategory string

// Evse defines model for Evse.
type Evse struct {
	Capabilities        *[]EvseCapabilities        `json:"capabilities,omitempty"`
	Connectors          []Connector                `json:"connectors"`
	Coordinates         *GeoLocation               `json:"coordinates,omitempty"`
	Directions          *[]DisplayText             `json:"directions,omitempty"`
	EvseId              *string                    `json:"evse_id"`
	FloorLevel          *string                    `json:"floor_level,omitempty"`
	Images              *[]Image                   `json:"images,omitempty"`
	LastUpdated         string                     `json:"last_updated"`
	ParkingRestrictions *[]EvseParkingRestrictions `json:"parking_restrictions,omitempty"`
	PhysicalReference   *string                    `json:"physical_reference,omitempty"`
	Status              EvseStatus                 `json:"status"`
	StatusSchedule      *[]StatusSchedule          `json:"status_schedule,omitempty"`

	// Uid Uniquely identifies the EVSE within the CPOs platform (and
	// suboperator platforms).
	Uid string `json:"uid"`
}

// EvseCapabilities defines model for Evse.Capabilities.
type EvseCapabilities string

// EvseParkingRestrictions defines model for Evse.ParkingRestrictions.
type EvseParkingRestrictions string

// EvseStatus defines model for Evse.Status.
type EvseStatus string

// ExceptionalPeriod defines model for ExceptionalPeriod.
type ExceptionalPeriod struct {
	PeriodBegin string `json:"period_begin"`
	PeriodEnd   string `json:"period_end"`
}

// GenericChargingProfileResult defines model for GenericChargingProfileResult.
type GenericChargingProfileResult struct {
	Profile *ActiveChargingProfile             `json:"profile,omitempty"`
	Result  GenericChargingProfileResultResult `json:"result"`
}

// GenericChargingProfileResultResult defines model for GenericChargingProfileResult.Result.
type GenericChargingProfileResultResult string

// GeoLocation defines model for GeoLocation.
type GeoLocation struct {
	Latitude  string `json:"latitude"`
	Longitude string `json:"longitude"`
}

// Hours defines model for Hours.
type Hours struct {
	ExceptionalClosings *ExceptionalPeriod `json:"exceptional_closings,omitempty"`
	ExceptionalOpenings *ExceptionalPeriod `json:"exceptional_openings,omitempty"`
	RegularHours        *RegularHours      `json:"regular_hours,omitempty"`
	Twentyfourseven     bool               `json:"twentyfourseven"`
}

// Image defines model for Image.
type Image struct {
	Category  ImageCategory `json:"category"`
	Height    *int32        `json:"height"`
	Thumbnail *string       `json:"thumbnail"`
	Type      string        `json:"type"`
	Url       string        `json:"url"`
	Width     *int32        `json:"width"`
}

// ImageCategory defines model for Image.Category.
type ImageCategory string

// Location defines model for Location.
type Location struct {
	Address            string                   `json:"address"`
	ChargingWhenClosed *string                  `json:"charging_when_closed,omitempty"`
	City               string                   `json:"city"`
	Coordinates        GeoLocation              `json:"coordinates"`
	Country            string                   `json:"country"`
	CountryCode        string                   `json:"country_code"`
	Directions         *[]DisplayText           `json:"directions,omitempty"`
	EnergyMix          *EnergyMix               `json:"energy_mix,omitempty"`
	Evses              *[]Evse                  `json:"evses,omitempty"`
	Facilities         *[]LocationFacilities    `json:"facilities,omitempty"`
	Id                 string                   `json:"id"`
	Images             *[]Image                 `json:"images,omitempty"`
	LastUpdated        string                   `json:"last_updated"`
	Name               *string                  `json:"name"`
	OpeningTimes       *Hours                   `json:"opening_times,omitempty"`
	Operator           *BusinessDetails         `json:"operator,omitempty"`
	Owner              *BusinessDetails         `json:"owner,omitempty"`
	ParkingType        *LocationParkingType     `json:"parking_type"`
	PartyId            string                   `json:"party_id"`
	PostalCode         *string                  `json:"postal_code"`
	Publish            bool                     `json:"publish"`
	PublishAllowedTo   *[]PublishTokenType      `json:"publish_allowed_to,omitempty"`
	RelatedLocations   *[]AdditionalGeoLocation `json:"related_locations,omitempty"`
	State              *string                  `json:"state"`
	Suboperator        *BusinessDetails         `json:"suboperator,omitempty"`
	TimeZone           *string                  `json:"time_zone,omitempty"`
}

// LocationFacilities defines model for Location.Facilities.
type LocationFacilities string

// LocationParkingType defines model for Location.ParkingType.
type LocationParkingType string

// LocationReferences defines model for LocationReferences.
type LocationReferences struct {
	ConnectorIds *[]string `json:"connector_ids,omitempty"`
	EvseUids     *[]string `json:"evse_uids,omitempty"`
	LocationId   string    `json:"location_id"`
}

// OcpiResponse defines model for OcpiResponse.
type OcpiResponse struct {
	Data          *map[string]interface{} `json:"data,omitempty"`
	StatusCode    int32                   `json:"status_code"`
	StatusMessage *string                 `json:"status_message,omitempty"`
	Timestamp     string                  `json:"timestamp"`
}

// OcpiResponseAuthorizationInfo defines model for OcpiResponseAuthorizationInfo.
type OcpiResponseAuthorizationInfo struct {
	Data          *AuthorizationInfo `json:"data,omitempty"`
	StatusCode    int32              `json:"status_code"`
	StatusMessage *string            `json:"status_message,omitempty"`
	Timestamp     string             `json:"timestamp"`
}

// OcpiResponseCDR defines model for OcpiResponseCDR.
type OcpiResponseCDR struct {
	Data          *CDR    `json:"data,omitempty"`
	StatusCode    int32   `json:"status_code"`
	StatusMessage *string `json:"status_message,omitempty"`
	Timestamp     string  `json:"timestamp"`
}

// OcpiResponseCDRList defines model for OcpiResponseCDRList.
type OcpiResponseCDRList struct {
	Data          *[]CDR  `json:"data,omitempty"`
	StatusCode    int32   `json:"status_code"`
	StatusMessage *string `json:"status_message,omitempty"`
	Timestamp     string  `json:"timestamp"`
}

// OcpiResponseChargingPreferencesResponse defines model for OcpiResponseChargingPreferencesResponse.
type OcpiResponseChargingPreferencesResponse struct {
	Data          *OcpiResponseChargingPreferencesResponseData `json:"data,omitempty"`
	StatusCode    int32                                        `json:"status_code"`
	StatusMessage *string                                      `json:"status_message,omitempty"`
	Timestamp     string                                       `json:"timestamp"`
}

// OcpiResponseChargingPreferencesResponseData defines model for OcpiResponseChargingPreferencesResponse.Data.
type OcpiResponseChargingPreferencesResponseData string

// OcpiResponseChargingProfileResponse defines model for OcpiResponseChargingProfileResponse.
type OcpiResponseChargingProfileResponse struct {
	Data          *ChargingProfileResponse `json:"data,omitempty"`
	StatusCode    int32                    `json:"status_code"`
	StatusMessage *string                  `json:"status_message,omitempty"`
	Timestamp     string                   `json:"timestamp"`
}

// OcpiResponseCommandResponse defines model for OcpiResponseCommandResponse.
type OcpiResponseCommandResponse struct {
	Data          *CommandResponse `json:"data,omitempty"`
	StatusCode    int32            `json:"status_code"`
	StatusMessage *string          `json:"status_message,omitempty"`
	Timestamp     string           `json:"timestamp"`
}

// OcpiResponseConnector defines model for OcpiResponseConnector.
type OcpiResponseConnector struct {
	Data          *Connector `json:"data,omitempty"`
	StatusCode    int32      `json:"status_code"`
	StatusMessage *string    `json:"status_message,omitempty"`
	Timestamp     string     `json:"timestamp"`
}

// OcpiResponseCredentials defines model for OcpiResponseCredentials.
type OcpiResponseCredentials struct {
	Data          *Credentials `json:"data,omitempty"`
	StatusCode    int32        `json:"status_code"`
	StatusMessage *string      `json:"status_message,omitempty"`
	Timestamp     string       `json:"timestamp"`
}

// OcpiResponseEvse defines model for OcpiResponseEvse.
type OcpiResponseEvse struct {
	Data          *Evse   `json:"data,omitempty"`
	StatusCode    int32   `json:"status_code"`
	StatusMessage *string `json:"status_message,omitempty"`
	Timestamp     string  `json:"timestamp"`
}

// OcpiResponseListVersion defines model for OcpiResponseListVersion.
type OcpiResponseListVersion struct {
	Data          *[]Version `json:"data,omitempty"`
	StatusCode    int32      `json:"status_code"`
	StatusMessage *string    `json:"status_message,omitempty"`
	Timestamp     string     `json:"timestamp"`
}

// OcpiResponseLocation defines model for OcpiResponseLocation.
type OcpiResponseLocation struct {
	Data          *Location `json:"data,omitempty"`
	StatusCode    int32     `json:"status_code"`
	StatusMessage *string   `json:"status_message,omitempty"`
	Timestamp     string    `json:"timestamp"`
}

// OcpiResponseLocationList defines model for OcpiResponseLocationList.
type OcpiResponseLocationList struct {
	Data          *[]Location `json:"data,omitempty"`
	StatusCode    int32       `json:"status_code"`
	StatusMessage *string     `json:"status_message,omitempty"`
	Timestamp     string      `json:"timestamp"`
}

// OcpiResponseSession defines model for OcpiResponseSession.
type OcpiResponseSession struct {
	Data          *Session `json:"data,omitempty"`
	StatusCode    int32    `json:"status_code"`
	StatusMessage *string  `json:"status_message,omitempty"`
	Timestamp     string   `json:"timestamp"`
}

// OcpiResponseSessionList defines model for OcpiResponseSessionList.
type OcpiResponseSessionList struct {
	Data          *[]Session `json:"data,omitempty"`
	StatusCode    int32      `json:"status_code"`
	StatusMessage *string    `json:"status_message,omitempty"`
	Timestamp     string     `json:"timestamp"`
}

// OcpiResponseTariff defines model for OcpiResponseTariff.
type OcpiResponseTariff struct {
	Data          *Tariff `json:"data,omitempty"`
	StatusCode    int32   `json:"status_code"`
	StatusMessage *string `json:"status_message,omitempty"`
	Timestamp     string  `json:"timestamp"`
}

// OcpiResponseTariffList defines model for OcpiResponseTariffList.
type OcpiResponseTariffList struct {
	Data          *[]Tariff `json:"data,omitempty"`
	StatusCode    int32     `json:"status_code"`
	StatusMessage *string   `json:"status_message,omitempty"`
	Timestamp     string    `json:"timestamp"`
}

// OcpiResponseToken defines model for OcpiResponseToken.
type OcpiResponseToken struct {
	Data          *Token  `json:"data,omitempty"`
	StatusCode    int32   `json:"status_code"`
	StatusMessage *string `json:"status_message,omitempty"`
	Timestamp     string  `json:"timestamp"`
}

// OcpiResponseTokenList defines model for OcpiResponseTokenList.
type OcpiResponseTokenList struct {
	Data          *[]Token `json:"data,omitempty"`
	StatusCode    int32    `json:"status_code"`
	StatusMessage *string  `json:"status_message,omitempty"`
	Timestamp     string   `json:"timestamp"`
}

// OcpiResponseUnit defines model for OcpiResponseUnit.
type OcpiResponseUnit struct {
	Data          *Unit   `json:"data,omitempty"`
	StatusCode    int32   `json:"status_code"`
	StatusMessage *string `json:"status_message,omitempty"`
	Timestamp     string  `json:"timestamp"`
}

// OcpiResponseVersionDetail defines model for OcpiResponseVersionDetail.
type OcpiResponseVersionDetail struct {
	Data          *VersionDetail `json:"data,omitempty"`
	StatusCode    int32          `json:"status_code"`
	StatusMessage *string        `json:"status_message,omitempty"`
	Timestamp     string         `json:"timestamp"`
}

// Price defines model for Price.
type Price struct {
	ExclVat float32 `json:"excl_vat"`
	InclVat float32 `json:"incl_vat"`
}

// PriceComponent defines model for PriceComponent.
type PriceComponent struct {
	Price    float32            `json:"price"`
	StepSize int32              `json:"step_size"`
	Type     PriceComponentType `json:"type"`
	Vat      *float32           `json:"vat,omitempty"`
}

// PriceComponentType defines model for PriceComponent.Type.
type PriceComponentType string

// PublishTokenType defines model for PublishTokenType.
type PublishTokenType struct {
	GroupId      *string               `json:"group_id ,omitempty"`
	Issuer       *string               `json:"issuer,omitempty"`
	Type         *PublishTokenTypeType `json:"type,omitempty"`
	Uid          *string               `json:"uid,omitempty"`
	VisualNumber *string               `json:"visual_number,omitempty"`
}

// PublishTokenTypeType defines model for PublishTokenType.Type.
type PublishTokenTypeType string

// RegularHours defines model for RegularHours.
type RegularHours struct {
	PeriodBegin string `json:"period_begin"`
	PeriodEnd   string `json:"period_end"`
	Weekday     int32  `json:"weekday"`
}

// ReserveNow defines model for ReserveNow.
type ReserveNow struct {
	AuthorizationReference *string `json:"authorization_reference,omitempty"`
	EvseUid                *string `json:"evse_uid,omitempty"`
	ExpiryDate             string  `json:"expiry_date"`
	LocationId             string  `json:"location_id"`
	ReservationId          string  `json:"reservation_id"`
	ResponseUrl            string  `json:"response_url"`
	Token                  Token   `json:"token"`
}

// Session defines model for Session.
type Session struct {
	AuthMethod             SessionAuthMethod `json:"auth_method"`
	AuthorizationReference *string           `json:"authorization_reference,omitempty"`
	CdrToken               CdrToken          `json:"cdr_token"`
	ChargingPeriods        *[]ChargingPeriod `json:"charging_periods,omitempty"`
	ConnectorId            string            `json:"connector_id"`
	CountryCode            string            `json:"country_code"`
	Currency               string            `json:"currency"`
	EndDateTime            *string           `json:"end_date_time,omitempty"`
	EvseUid                string            `json:"evse_uid"`
	Id                     string            `json:"id"`
	Kwh                    float32           `json:"kwh"`
	LastUpdated            string            `json:"last_updated"`
	LocationId             string            `json:"location_id"`
	MeterId                *string           `json:"meter_id,omitempty"`
	PartyId                string            `json:"party_id"`
	StartDateTime          string            `json:"start_date_time"`
	Status                 SessionStatus     `json:"status"`
	TotalCost              *Price            `json:"total_cost,omitempty"`
}

// SessionAuthMethod defines model for Session.AuthMethod.
type SessionAuthMethod string

// SessionStatus defines model for Session.Status.
type SessionStatus string

// SetChargingProfile defines model for SetChargingProfile.
type SetChargingProfile struct {
	ChargingProfile ChargingProfile `json:"charging_profile"`
	ResponseUrl     string          `json:"response_url"`
}

// SignedData defines model for SignedData.
type SignedData struct {
	EncodingMethod        string        `json:"encoding_method"`
	EncodingMethodVersion *int32        `json:"encoding_method_version,omitempty"`
	PublicKey             *string       `json:"public_key,omitempty"`
	SignedValues          []SignedValue `json:"signed_values"`
	Url                   string        `json:"url"`
}

// SignedValue defines model for SignedValue.
type SignedValue struct {
	Nature     string `json:"nature"`
	PlainData  string `json:"plain_data"`
	SignedData string `json:"signed_data"`
}

// StartSession defines model for StartSession.
type StartSession struct {
	AuthorizationReference *string `json:"authorization_reference,omitempty"`
	ConnectorId            *string `json:"connector_id,omitempty"`
	EvseUid                *string `json:"evse_uid,omitempty"`
	LocationId             string  `json:"location_id"`
	ResponseUrl            string  `json:"response_url"`
	Token                  Token   `json:"token"`
}

// StatusSchedule defines model for StatusSchedule.
type StatusSchedule struct {
	PeriodBegin string               `json:"period_begin"`
	PeriodEnd   *string              `json:"period_end,omitempty"`
	Status      StatusScheduleStatus `json:"status"`
}

// StatusScheduleStatus defines model for StatusSchedule.Status.
type StatusScheduleStatus string

// StopSession defines model for StopSession.
type StopSession struct {
	ResponseUrl string `json:"response_url"`
	SessionId   string `json:"session_id"`
}

// Tariff defines model for Tariff.
type Tariff struct {
	CountryCode   string          `json:"country_code"`
	Currency      string          `json:"currency"`
	Elements      []TariffElement `json:"elements"`
	EndDateTime   *string         `json:"end_date_time,omitempty"`
	EnergyMix     *EnergyMix      `json:"energy_mix,omitempty"`
	Id            string          `json:"id"`
	LastUpdated   string          `json:"last_updated"`
	MaxPrice      *Price          `json:"max_price,omitempty"`
	MinPrice      *Price          `json:"min_price,omitempty"`
	PartyId       string          `json:"party_id"`
	StartDateTime *string         `json:"start_date_time,omitempty"`
	TariffAltText *[]DisplayText  `json:"tariff_alt_text,omitempty"`
	TariffAltUrl  *string         `json:"tariff_alt_url,omitempty"`
	Type          *TariffType     `json:"type,omitempty"`
}

// TariffType defines model for Tariff.Type.
type TariffType string

// TariffElement defines model for TariffElement.
type TariffElement struct {
	PriceComponents []PriceComponent    `json:"price_components"`
	Restrictions    *TariffRestrictions `json:"restrictions,omitempty"`
}

// TariffRestrictions defines model for TariffRestrictions.
type TariffRestrictions struct {
	DayOfWeek   *[]TariffRestrictionsDayOfWeek `json:"day_of_week,omitempty"`
	EndDate     *string                        `json:"end_date,omitempty"`
	EndTime     *string                        `json:"end_time,omitempty"`
	MaxCurrent  *float32                       `json:"max_current,omitempty"`
	MaxDuration *int32                         `json:"max_duration,omitempty"`
	MaxKwh      *float32                       `json:"max_kwh,omitempty"`
	MaxPower    *float32                       `json:"max_power,omitempty"`
	MinCurrent  *float32                       `json:"min_current,omitempty"`
	MinDuration *int32                         `json:"min_duration,omitempty"`
	MinKwh      *float32                       `json:"min_kwh,omitempty"`
	MinPower    *float32                       `json:"min_power,omitempty"`
	Reservation *TariffRestrictionsReservation `json:"reservation,omitempty"`
	StartDate   *string                        `json:"start_date,omitempty"`
	StartTime   *string                        `json:"start_time,omitempty"`
}

// TariffRestrictionsDayOfWeek defines model for TariffRestrictions.DayOfWeek.
type TariffRestrictionsDayOfWeek string

// TariffRestrictionsReservation defines model for TariffRestrictions.Reservation.
type TariffRestrictionsReservation string

// Token defines model for Token.
type Token struct {
	ContractId         string                   `json:"contract_id"`
	CountryCode        string                   `json:"country_code"`
	DefaultProfileType *TokenDefaultProfileType `json:"default_profile_type,omitempty"`
	EnergyContract     *EnergyContract          `json:"energy_contract,omitempty"`
	GroupId            *string                  `json:"group_id,omitempty"`
	Issuer             string                   `json:"issuer"`
	Language           *string                  `json:"language,omitempty"`
	LastUpdated        string                   `json:"last_updated"`
	PartyId            string                   `json:"party_id"`
	Type               TokenType                `json:"type"`
	Uid                string                   `json:"uid"`
	Valid              bool                     `json:"valid"`
	VisualNumber       *string                  `json:"visual_number,omitempty"`
	Whitelist          TokenWhitelist           `json:"whitelist"`
}

// TokenDefaultProfileType defines model for Token.DefaultProfileType.
type TokenDefaultProfileType string

// TokenType defines model for Token.Type.
type TokenType string

// TokenWhitelist defines model for Token.Whitelist.
type TokenWhitelist string

// Unit defines model for Unit.
type Unit = map[string]interface{}

// UnlockConnector defines model for UnlockConnector.
type UnlockConnector struct {
	ConnectorId string `json:"connector_id"`
	EvseUid     string `json:"evse_uid"`
	LocationId  string `json:"location_id"`
	ResponseUrl string `json:"response_url"`
}

// Version defines model for Version.
type Version struct {
	Url     string `json:"url"`
	Version string `json:"version"`
}

// VersionDetail defines model for VersionDetail.
type VersionDetail struct {
	Endpoints []Endpoint `json:"endpoints"`
	Version   string     `json:"version"`
}

// GetVersionParams defines parameters for GetVersion.
type GetVersionParams struct {
	Authorization string `json:"Authorization"`
}

// DeleteCredentialsParams defines parameters for DeleteCredentials.
type DeleteCredentialsParams struct {
	Authorization string `json:"Authorization"`
}

// GetCredentialsParams defines parameters for GetCredentials.
type GetCredentialsParams struct {
	Authorization string `json:"Authorization"`
}

// PostCredentialsParams defines parameters for PostCredentials.
type PostCredentialsParams struct {
	Authorization string `json:"Authorization"`
}

// PutCredentialsParams defines parameters for PutCredentials.
type PutCredentialsParams struct {
	Authorization string `json:"Authorization"`
}

// DeleteReceiverChargingProfileParams defines parameters for DeleteReceiverChargingProfile.
type DeleteReceiverChargingProfileParams struct {
	ResponseUrl         string `form:"response_url" json:"response_url"`
	Authorization       string `json:"Authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// GetReceiverChargingProfileParams defines parameters for GetReceiverChargingProfile.
type GetReceiverChargingProfileParams struct {
	Duration            int32  `form:"duration" json:"duration"`
	ResponseUrl         string `form:"response_url" json:"response_url"`
	Authorization       string `json:"Authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// PutReceiverChargingProfileParams defines parameters for PutReceiverChargingProfile.
type PutReceiverChargingProfileParams struct {
	Authorization       string `json:"Authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// PostGenericChargingProfileResultParams defines parameters for PostGenericChargingProfileResult.
type PostGenericChargingProfileResultParams struct {
	Authorization       string `json:"Authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// PutSenderChargingProfileParams defines parameters for PutSenderChargingProfile.
type PutSenderChargingProfileParams struct {
	Authorization       string `json:"Authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// PostClientOwnedCdrParams defines parameters for PostClientOwnedCdr.
type PostClientOwnedCdrParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// GetClientOwnedCdrParams defines parameters for GetClientOwnedCdr.
type GetClientOwnedCdrParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// PostCancelReservationParams defines parameters for PostCancelReservation.
type PostCancelReservationParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// PostReserveNowParams defines parameters for PostReserveNow.
type PostReserveNowParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// PostStartSessionParams defines parameters for PostStartSession.
type PostStartSessionParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// PostStopSessionParams defines parameters for PostStopSession.
type PostStopSessionParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// PostUnlockConnectorParams defines parameters for PostUnlockConnector.
type PostUnlockConnectorParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// GetClientOwnedLocationParams defines parameters for GetClientOwnedLocation.
type GetClientOwnedLocationParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// PatchClientOwnedLocationJSONBody defines parameters for PatchClientOwnedLocation.
type PatchClientOwnedLocationJSONBody map[string]map[string]interface{}

// PatchClientOwnedLocationParams defines parameters for PatchClientOwnedLocation.
type PatchClientOwnedLocationParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// PutClientOwnedLocationParams defines parameters for PutClientOwnedLocation.
type PutClientOwnedLocationParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// GetClientOwnedEvseParams defines parameters for GetClientOwnedEvse.
type GetClientOwnedEvseParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// PatchClientOwnedEvseJSONBody defines parameters for PatchClientOwnedEvse.
type PatchClientOwnedEvseJSONBody map[string]map[string]interface{}

// PatchClientOwnedEvseParams defines parameters for PatchClientOwnedEvse.
type PatchClientOwnedEvseParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// PutClientOwnedEvseParams defines parameters for PutClientOwnedEvse.
type PutClientOwnedEvseParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// GetClientOwnedConnectorParams defines parameters for GetClientOwnedConnector.
type GetClientOwnedConnectorParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// PatchClientOwnedConnectorJSONBody defines parameters for PatchClientOwnedConnector.
type PatchClientOwnedConnectorJSONBody map[string]map[string]interface{}

// PatchClientOwnedConnectorParams defines parameters for PatchClientOwnedConnector.
type PatchClientOwnedConnectorParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// PutClientOwnedConnectorParams defines parameters for PutClientOwnedConnector.
type PutClientOwnedConnectorParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// GetClientOwnedSessionParams defines parameters for GetClientOwnedSession.
type GetClientOwnedSessionParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// PatchClientOwnedSessionJSONBody defines parameters for PatchClientOwnedSession.
type PatchClientOwnedSessionJSONBody map[string]map[string]interface{}

// PatchClientOwnedSessionParams defines parameters for PatchClientOwnedSession.
type PatchClientOwnedSessionParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// PutClientOwnedSessionParams defines parameters for PutClientOwnedSession.
type PutClientOwnedSessionParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// DeleteClientOwnedTariffParams defines parameters for DeleteClientOwnedTariff.
type DeleteClientOwnedTariffParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// GetClientOwnedTariffParams defines parameters for GetClientOwnedTariff.
type GetClientOwnedTariffParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// PutClientOwnedTariffParams defines parameters for PutClientOwnedTariff.
type PutClientOwnedTariffParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// GetClientOwnedTokenParams defines parameters for GetClientOwnedToken.
type GetClientOwnedTokenParams struct {
	Type                *GetClientOwnedTokenParamsType `form:"type,omitempty" json:"type,omitempty"`
	Authorization       string                         `json:"authorization"`
	XRequestID          string                         `json:"X-Request-ID"`
	XCorrelationID      string                         `json:"X-Correlation-ID"`
	OCPIFromCountryCode string                         `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string                         `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string                         `json:"OCPI-to-country-code"`
	OCPIToPartyId       string                         `json:"OCPI-to-party-id"`
}

// GetClientOwnedTokenParamsType defines parameters for GetClientOwnedToken.
type GetClientOwnedTokenParamsType string

// PatchClientOwnedTokenJSONBody defines parameters for PatchClientOwnedToken.
type PatchClientOwnedTokenJSONBody map[string]map[string]interface{}

// PatchClientOwnedTokenParams defines parameters for PatchClientOwnedToken.
type PatchClientOwnedTokenParams struct {
	Type                *PatchClientOwnedTokenParamsType `form:"type,omitempty" json:"type,omitempty"`
	Authorization       string                           `json:"authorization"`
	XRequestID          string                           `json:"X-Request-ID"`
	XCorrelationID      string                           `json:"X-Correlation-ID"`
	OCPIFromCountryCode string                           `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string                           `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string                           `json:"OCPI-to-country-code"`
	OCPIToPartyId       string                           `json:"OCPI-to-party-id"`
}

// PatchClientOwnedTokenParamsType defines parameters for PatchClientOwnedToken.
type PatchClientOwnedTokenParamsType string

// PutClientOwnedTokenParams defines parameters for PutClientOwnedToken.
type PutClientOwnedTokenParams struct {
	Type                *PutClientOwnedTokenParamsType `form:"type,omitempty" json:"type,omitempty"`
	Authorization       string                         `json:"authorization"`
	XRequestID          string                         `json:"X-Request-ID"`
	XCorrelationID      string                         `json:"X-Correlation-ID"`
	OCPIFromCountryCode string                         `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string                         `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string                         `json:"OCPI-to-country-code"`
	OCPIToPartyId       string                         `json:"OCPI-to-party-id"`
}

// PutClientOwnedTokenParamsType defines parameters for PutClientOwnedToken.
type PutClientOwnedTokenParamsType string

// GetCdrsFromDataOwnerParams defines parameters for GetCdrsFromDataOwner.
type GetCdrsFromDataOwnerParams struct {
	DateFrom            *string `form:"date_from,omitempty" json:"date_from,omitempty"`
	DateTo              *string `form:"date_to,omitempty" json:"date_to,omitempty"`
	Offset              *int32  `form:"offset,omitempty" json:"offset,omitempty"`
	Limit               *int32  `form:"limit,omitempty" json:"limit,omitempty"`
	Authorization       string  `json:"authorization"`
	XRequestID          string  `json:"X-Request-ID"`
	XCorrelationID      string  `json:"X-Correlation-ID"`
	OCPIFromCountryCode string  `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string  `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string  `json:"OCPI-to-country-code"`
	OCPIToPartyId       string  `json:"OCPI-to-party-id"`
}

// GetCdrPageFromDataOwnerParams defines parameters for GetCdrPageFromDataOwner.
type GetCdrPageFromDataOwnerParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// PostAsyncResponseParams defines parameters for PostAsyncResponse.
type PostAsyncResponseParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// PostAsyncResponseParamsCommand defines parameters for PostAsyncResponse.
type PostAsyncResponseParamsCommand string

// GetLocationListFromDataOwnerParams defines parameters for GetLocationListFromDataOwner.
type GetLocationListFromDataOwnerParams struct {
	DateFrom            *string `form:"date_from,omitempty" json:"date_from,omitempty"`
	DateTo              *string `form:"date_to,omitempty" json:"date_to,omitempty"`
	Offset              *int32  `form:"offset,omitempty" json:"offset,omitempty"`
	Limit               *int32  `form:"limit,omitempty" json:"limit,omitempty"`
	Authorization       string  `json:"authorization"`
	XRequestID          string  `json:"X-Request-ID"`
	XCorrelationID      string  `json:"X-Correlation-ID"`
	OCPIFromCountryCode string  `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string  `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string  `json:"OCPI-to-country-code"`
	OCPIToPartyId       string  `json:"OCPI-to-party-id"`
}

// GetLocationPageFromDataOwnerParams defines parameters for GetLocationPageFromDataOwner.
type GetLocationPageFromDataOwnerParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// GetLocationObjectFromDataOwnerParams defines parameters for GetLocationObjectFromDataOwner.
type GetLocationObjectFromDataOwnerParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// GetEvseObjectFromDataOwnerParams defines parameters for GetEvseObjectFromDataOwner.
type GetEvseObjectFromDataOwnerParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// GetConnectorObjectFromDataOwnerParams defines parameters for GetConnectorObjectFromDataOwner.
type GetConnectorObjectFromDataOwnerParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// GetSessionsFromDataOwnerParams defines parameters for GetSessionsFromDataOwner.
type GetSessionsFromDataOwnerParams struct {
	DateFrom            *string `form:"date_from,omitempty" json:"date_from,omitempty"`
	DateTo              *string `form:"date_to,omitempty" json:"date_to,omitempty"`
	Offset              *int32  `form:"offset,omitempty" json:"offset,omitempty"`
	Limit               *int32  `form:"limit,omitempty" json:"limit,omitempty"`
	Authorization       string  `json:"authorization"`
	XRequestID          string  `json:"X-Request-ID"`
	XCorrelationID      string  `json:"X-Correlation-ID"`
	OCPIFromCountryCode string  `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string  `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string  `json:"OCPI-to-country-code"`
	OCPIToPartyId       string  `json:"OCPI-to-party-id"`
}

// GetSessionsPageFromDataOwnerParams defines parameters for GetSessionsPageFromDataOwner.
type GetSessionsPageFromDataOwnerParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// PutChargingPreferencesParams defines parameters for PutChargingPreferences.
type PutChargingPreferencesParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// GetTariffsFromDataOwnerParams defines parameters for GetTariffsFromDataOwner.
type GetTariffsFromDataOwnerParams struct {
	DateFrom            *string `form:"date_from,omitempty" json:"date_from,omitempty"`
	DateTo              *string `form:"date_to,omitempty" json:"date_to,omitempty"`
	Offset              *int32  `form:"offset,omitempty" json:"offset,omitempty"`
	Limit               *int32  `form:"limit,omitempty" json:"limit,omitempty"`
	Authorization       string  `json:"authorization"`
	XRequestID          string  `json:"X-Request-ID"`
	XCorrelationID      string  `json:"X-Correlation-ID"`
	OCPIFromCountryCode string  `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string  `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string  `json:"OCPI-to-country-code"`
	OCPIToPartyId       string  `json:"OCPI-to-party-id"`
}

// GetTariffsPageFromDataOwnerParams defines parameters for GetTariffsPageFromDataOwner.
type GetTariffsPageFromDataOwnerParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// GetTokensFromDataOwnerParams defines parameters for GetTokensFromDataOwner.
type GetTokensFromDataOwnerParams struct {
	DateFrom            *string `form:"date_from,omitempty" json:"date_from,omitempty"`
	DateTo              *string `form:"date_to,omitempty" json:"date_to,omitempty"`
	Offset              *int32  `form:"offset,omitempty" json:"offset,omitempty"`
	Limit               *int32  `form:"limit,omitempty" json:"limit,omitempty"`
	Authorization       string  `json:"authorization"`
	XRequestID          string  `json:"X-Request-ID"`
	XCorrelationID      string  `json:"X-Correlation-ID"`
	OCPIFromCountryCode string  `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string  `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string  `json:"OCPI-to-country-code"`
	OCPIToPartyId       string  `json:"OCPI-to-party-id"`
}

// GetTokensPageFromDataOwnerParams defines parameters for GetTokensPageFromDataOwner.
type GetTokensPageFromDataOwnerParams struct {
	Authorization       string `json:"authorization"`
	XRequestID          string `json:"X-Request-ID"`
	XCorrelationID      string `json:"X-Correlation-ID"`
	OCPIFromCountryCode string `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string `json:"OCPI-to-country-code"`
	OCPIToPartyId       string `json:"OCPI-to-party-id"`
}

// PostRealTimeTokenAuthorizationParams defines parameters for PostRealTimeTokenAuthorization.
type PostRealTimeTokenAuthorizationParams struct {
	Type                *PostRealTimeTokenAuthorizationParamsType `form:"type,omitempty" json:"type,omitempty"`
	Authorization       string                                    `json:"authorization"`
	XRequestID          string                                    `json:"X-Request-ID"`
	XCorrelationID      string                                    `json:"X-Correlation-ID"`
	OCPIFromCountryCode string                                    `json:"OCPI-from-country-code"`
	OCPIFromPartyId     string                                    `json:"OCPI-from-party-id"`
	OCPIToCountryCode   string                                    `json:"OCPI-to-country-code"`
	OCPIToPartyId       string                                    `json:"OCPI-to-party-id"`
}

// PostRealTimeTokenAuthorizationParamsType defines parameters for PostRealTimeTokenAuthorization.
type PostRealTimeTokenAuthorizationParamsType string

// GetVersionsParams defines parameters for GetVersions.
type GetVersionsParams struct {
	Authorization string `json:"Authorization"`
}

// PostCredentialsJSONRequestBody defines body for PostCredentials for application/json ContentType.
type PostCredentialsJSONRequestBody = Credentials

// PutCredentialsJSONRequestBody defines body for PutCredentials for application/json ContentType.
type PutCredentialsJSONRequestBody = Credentials

// PutReceiverChargingProfileJSONRequestBody defines body for PutReceiverChargingProfile for application/json ContentType.
type PutReceiverChargingProfileJSONRequestBody = SetChargingProfile

// PostGenericChargingProfileResultJSONRequestBody defines body for PostGenericChargingProfileResult for application/json ContentType.
type PostGenericChargingProfileResultJSONRequestBody = GenericChargingProfileResult

// PutSenderChargingProfileJSONRequestBody defines body for PutSenderChargingProfile for application/json ContentType.
type PutSenderChargingProfileJSONRequestBody = ActiveChargingProfile

// PostClientOwnedCdrJSONRequestBody defines body for PostClientOwnedCdr for application/json ContentType.
type PostClientOwnedCdrJSONRequestBody = CDR

// PostCancelReservationJSONRequestBody defines body for PostCancelReservation for application/json ContentType.
type PostCancelReservationJSONRequestBody = CancelReservation

// PostReserveNowJSONRequestBody defines body for PostReserveNow for application/json ContentType.
type PostReserveNowJSONRequestBody = ReserveNow

// PostStartSessionJSONRequestBody defines body for PostStartSession for application/json ContentType.
type PostStartSessionJSONRequestBody = StartSession

// PostStopSessionJSONRequestBody defines body for PostStopSession for application/json ContentType.
type PostStopSessionJSONRequestBody = StopSession

// PostUnlockConnectorJSONRequestBody defines body for PostUnlockConnector for application/json ContentType.
type PostUnlockConnectorJSONRequestBody = UnlockConnector

// PatchClientOwnedLocationJSONRequestBody defines body for PatchClientOwnedLocation for application/json ContentType.
type PatchClientOwnedLocationJSONRequestBody PatchClientOwnedLocationJSONBody

// PutClientOwnedLocationJSONRequestBody defines body for PutClientOwnedLocation for application/json ContentType.
type PutClientOwnedLocationJSONRequestBody = Location

// PatchClientOwnedEvseJSONRequestBody defines body for PatchClientOwnedEvse for application/json ContentType.
type PatchClientOwnedEvseJSONRequestBody PatchClientOwnedEvseJSONBody

// PutClientOwnedEvseJSONRequestBody defines body for PutClientOwnedEvse for application/json ContentType.
type PutClientOwnedEvseJSONRequestBody = Evse

// PatchClientOwnedConnectorJSONRequestBody defines body for PatchClientOwnedConnector for application/json ContentType.
type PatchClientOwnedConnectorJSONRequestBody PatchClientOwnedConnectorJSONBody

// PutClientOwnedConnectorJSONRequestBody defines body for PutClientOwnedConnector for application/json ContentType.
type PutClientOwnedConnectorJSONRequestBody = Connector

// PatchClientOwnedSessionJSONRequestBody defines body for PatchClientOwnedSession for application/json ContentType.
type PatchClientOwnedSessionJSONRequestBody PatchClientOwnedSessionJSONBody

// PutClientOwnedSessionJSONRequestBody defines body for PutClientOwnedSession for application/json ContentType.
type PutClientOwnedSessionJSONRequestBody = Session

// PutClientOwnedTariffJSONRequestBody defines body for PutClientOwnedTariff for application/json ContentType.
type PutClientOwnedTariffJSONRequestBody = Tariff

// PatchClientOwnedTokenJSONRequestBody defines body for PatchClientOwnedToken for application/json ContentType.
type PatchClientOwnedTokenJSONRequestBody PatchClientOwnedTokenJSONBody

// PutClientOwnedTokenJSONRequestBody defines body for PutClientOwnedToken for application/json ContentType.
type PutClientOwnedTokenJSONRequestBody = Token

// PostAsyncResponseJSONRequestBody defines body for PostAsyncResponse for application/json ContentType.
type PostAsyncResponseJSONRequestBody = CommandResult

// PutChargingPreferencesJSONRequestBody defines body for PutChargingPreferences for application/json ContentType.
type PutChargingPreferencesJSONRequestBody = ChargingPreferences

// PostRealTimeTokenAuthorizationJSONRequestBody defines body for PostRealTimeTokenAuthorization for application/json ContentType.
type PostRealTimeTokenAuthorizationJSONRequestBody = LocationReferences

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /ocpi/2.2)
	GetVersion(w http.ResponseWriter, r *http.Request, params GetVersionParams)

	// (DELETE /ocpi/2.2/credentials)
	DeleteCredentials(w http.ResponseWriter, r *http.Request, params DeleteCredentialsParams)

	// (GET /ocpi/2.2/credentials)
	GetCredentials(w http.ResponseWriter, r *http.Request, params GetCredentialsParams)

	// (POST /ocpi/2.2/credentials)
	PostCredentials(w http.ResponseWriter, r *http.Request, params PostCredentialsParams)

	// (PUT /ocpi/2.2/credentials)
	PutCredentials(w http.ResponseWriter, r *http.Request, params PutCredentialsParams)

	// (DELETE /ocpi/2.2/receiver/chargingprofiles/{sessionId})
	DeleteReceiverChargingProfile(w http.ResponseWriter, r *http.Request, sessionId string, params DeleteReceiverChargingProfileParams)

	// (GET /ocpi/2.2/receiver/chargingprofiles/{sessionId})
	GetReceiverChargingProfile(w http.ResponseWriter, r *http.Request, sessionId string, params GetReceiverChargingProfileParams)

	// (PUT /ocpi/2.2/receiver/chargingprofiles/{sessionId})
	PutReceiverChargingProfile(w http.ResponseWriter, r *http.Request, sessionId string, params PutReceiverChargingProfileParams)

	// (POST /ocpi/2.2/sender/chargingprofiles/result/{uid})
	PostGenericChargingProfileResult(w http.ResponseWriter, r *http.Request, uid string, params PostGenericChargingProfileResultParams)

	// (PUT /ocpi/2.2/sender/chargingprofiles/{sessionId})
	PutSenderChargingProfile(w http.ResponseWriter, r *http.Request, sessionId string, params PutSenderChargingProfileParams)

	// (POST /ocpi/receiver/2.2/cdrs)
	PostClientOwnedCdr(w http.ResponseWriter, r *http.Request, params PostClientOwnedCdrParams)

	// (GET /ocpi/receiver/2.2/cdrs/{cdrID})
	GetClientOwnedCdr(w http.ResponseWriter, r *http.Request, cdrID string, params GetClientOwnedCdrParams)

	// (POST /ocpi/receiver/2.2/commands/CANCEL_RESERVATION)
	PostCancelReservation(w http.ResponseWriter, r *http.Request, params PostCancelReservationParams)

	// (POST /ocpi/receiver/2.2/commands/RESERVE_NOW)
	PostReserveNow(w http.ResponseWriter, r *http.Request, params PostReserveNowParams)

	// (POST /ocpi/receiver/2.2/commands/START_SESSION)
	PostStartSession(w http.ResponseWriter, r *http.Request, params PostStartSessionParams)

	// (POST /ocpi/receiver/2.2/commands/STOP_SESSION)
	PostStopSession(w http.ResponseWriter, r *http.Request, params PostStopSessionParams)

	// (POST /ocpi/receiver/2.2/commands/UNLOCK_CONNECTOR)
	PostUnlockConnector(w http.ResponseWriter, r *http.Request, params PostUnlockConnectorParams)

	// (GET /ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID})
	GetClientOwnedLocation(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, locationID string, params GetClientOwnedLocationParams)

	// (PATCH /ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID})
	PatchClientOwnedLocation(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, locationID string, params PatchClientOwnedLocationParams)

	// (PUT /ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID})
	PutClientOwnedLocation(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, locationID string, params PutClientOwnedLocationParams)

	// (GET /ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID}/{evseUID})
	GetClientOwnedEvse(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, locationID string, evseUID string, params GetClientOwnedEvseParams)

	// (PATCH /ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID}/{evseUID})
	PatchClientOwnedEvse(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, locationID string, evseUID string, params PatchClientOwnedEvseParams)

	// (PUT /ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID}/{evseUID})
	PutClientOwnedEvse(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, locationID string, evseUID string, params PutClientOwnedEvseParams)

	// (GET /ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID}/{evseUID}/{connectorID})
	GetClientOwnedConnector(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, locationID string, evseUID string, connectorID string, params GetClientOwnedConnectorParams)

	// (PATCH /ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID}/{evseUID}/{connectorID})
	PatchClientOwnedConnector(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, locationID string, evseUID string, connectorID string, params PatchClientOwnedConnectorParams)

	// (PUT /ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID}/{evseUID}/{connectorID})
	PutClientOwnedConnector(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, locationID string, evseUID string, connectorID string, params PutClientOwnedConnectorParams)

	// (GET /ocpi/receiver/2.2/sessions/{countryCode}/{partyID}/{sessionID})
	GetClientOwnedSession(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, sessionID string, params GetClientOwnedSessionParams)

	// (PATCH /ocpi/receiver/2.2/sessions/{countryCode}/{partyID}/{sessionID})
	PatchClientOwnedSession(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, sessionID string, params PatchClientOwnedSessionParams)

	// (PUT /ocpi/receiver/2.2/sessions/{countryCode}/{partyID}/{sessionID})
	PutClientOwnedSession(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, sessionID string, params PutClientOwnedSessionParams)

	// (DELETE /ocpi/receiver/2.2/tariffs/{countryCode}/{partyID}/{tariffID})
	DeleteClientOwnedTariff(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, tariffID string, params DeleteClientOwnedTariffParams)

	// (GET /ocpi/receiver/2.2/tariffs/{countryCode}/{partyID}/{tariffID})
	GetClientOwnedTariff(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, tariffID string, params GetClientOwnedTariffParams)

	// (PUT /ocpi/receiver/2.2/tariffs/{countryCode}/{partyID}/{tariffID})
	PutClientOwnedTariff(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, tariffID string, params PutClientOwnedTariffParams)

	// (GET /ocpi/receiver/2.2/tokens/{countryCode}/{partyID}/{tokenUID})
	GetClientOwnedToken(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, tokenUID string, params GetClientOwnedTokenParams)

	// (PATCH /ocpi/receiver/2.2/tokens/{countryCode}/{partyID}/{tokenUID})
	PatchClientOwnedToken(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, tokenUID string, params PatchClientOwnedTokenParams)

	// (PUT /ocpi/receiver/2.2/tokens/{countryCode}/{partyID}/{tokenUID})
	PutClientOwnedToken(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, tokenUID string, params PutClientOwnedTokenParams)

	// (GET /ocpi/sender/2.2/cdrs)
	GetCdrsFromDataOwner(w http.ResponseWriter, r *http.Request, params GetCdrsFromDataOwnerParams)

	// (GET /ocpi/sender/2.2/cdrs/page/{uid})
	GetCdrPageFromDataOwner(w http.ResponseWriter, r *http.Request, uid string, params GetCdrPageFromDataOwnerParams)

	// (POST /ocpi/sender/2.2/commands/{command}/{uid})
	PostAsyncResponse(w http.ResponseWriter, r *http.Request, command PostAsyncResponseParamsCommand, uid string, params PostAsyncResponseParams)

	// (GET /ocpi/sender/2.2/locations)
	GetLocationListFromDataOwner(w http.ResponseWriter, r *http.Request, params GetLocationListFromDataOwnerParams)

	// (GET /ocpi/sender/2.2/locations/page/{uid})
	GetLocationPageFromDataOwner(w http.ResponseWriter, r *http.Request, uid string, params GetLocationPageFromDataOwnerParams)

	// (GET /ocpi/sender/2.2/locations/{locationID})
	GetLocationObjectFromDataOwner(w http.ResponseWriter, r *http.Request, locationID string, params GetLocationObjectFromDataOwnerParams)

	// (GET /ocpi/sender/2.2/locations/{locationID}/{evseUID})
	GetEvseObjectFromDataOwner(w http.ResponseWriter, r *http.Request, locationID string, evseUID string, params GetEvseObjectFromDataOwnerParams)

	// (GET /ocpi/sender/2.2/locations/{locationID}/{evseUID}/{connectorID})
	GetConnectorObjectFromDataOwner(w http.ResponseWriter, r *http.Request, locationID string, evseUID string, connectorID string, params GetConnectorObjectFromDataOwnerParams)

	// (GET /ocpi/sender/2.2/sessions)
	GetSessionsFromDataOwner(w http.ResponseWriter, r *http.Request, params GetSessionsFromDataOwnerParams)

	// (GET /ocpi/sender/2.2/sessions/page/{uid})
	GetSessionsPageFromDataOwner(w http.ResponseWriter, r *http.Request, uid string, params GetSessionsPageFromDataOwnerParams)

	// (PUT /ocpi/sender/2.2/sessions/{sessionID}/charging_preferences)
	PutChargingPreferences(w http.ResponseWriter, r *http.Request, sessionID string, params PutChargingPreferencesParams)

	// (GET /ocpi/sender/2.2/tariffs)
	GetTariffsFromDataOwner(w http.ResponseWriter, r *http.Request, params GetTariffsFromDataOwnerParams)

	// (GET /ocpi/sender/2.2/tariffs/page/{uid})
	GetTariffsPageFromDataOwner(w http.ResponseWriter, r *http.Request, uid string, params GetTariffsPageFromDataOwnerParams)

	// (GET /ocpi/sender/2.2/tokens)
	GetTokensFromDataOwner(w http.ResponseWriter, r *http.Request, params GetTokensFromDataOwnerParams)

	// (GET /ocpi/sender/2.2/tokens/page/{uid})
	GetTokensPageFromDataOwner(w http.ResponseWriter, r *http.Request, uid string, params GetTokensPageFromDataOwnerParams)

	// (POST /ocpi/sender/2.2/tokens/{tokenUID}/authorize)
	PostRealTimeTokenAuthorization(w http.ResponseWriter, r *http.Request, tokenUID string, params PostRealTimeTokenAuthorizationParams)

	// (GET /ocpi/versions)
	GetVersions(w http.ResponseWriter, r *http.Request, params GetVersionsParams)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// (GET /ocpi/2.2)
func (_ Unimplemented) GetVersion(w http.ResponseWriter, r *http.Request, params GetVersionParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (DELETE /ocpi/2.2/credentials)
func (_ Unimplemented) DeleteCredentials(w http.ResponseWriter, r *http.Request, params DeleteCredentialsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /ocpi/2.2/credentials)
func (_ Unimplemented) GetCredentials(w http.ResponseWriter, r *http.Request, params GetCredentialsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /ocpi/2.2/credentials)
func (_ Unimplemented) PostCredentials(w http.ResponseWriter, r *http.Request, params PostCredentialsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (PUT /ocpi/2.2/credentials)
func (_ Unimplemented) PutCredentials(w http.ResponseWriter, r *http.Request, params PutCredentialsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (DELETE /ocpi/2.2/receiver/chargingprofiles/{sessionId})
func (_ Unimplemented) DeleteReceiverChargingProfile(w http.ResponseWriter, r *http.Request, sessionId string, params DeleteReceiverChargingProfileParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /ocpi/2.2/receiver/chargingprofiles/{sessionId})
func (_ Unimplemented) GetReceiverChargingProfile(w http.ResponseWriter, r *http.Request, sessionId string, params GetReceiverChargingProfileParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (PUT /ocpi/2.2/receiver/chargingprofiles/{sessionId})
func (_ Unimplemented) PutReceiverChargingProfile(w http.ResponseWriter, r *http.Request, sessionId string, params PutReceiverChargingProfileParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /ocpi/2.2/sender/chargingprofiles/result/{uid})
func (_ Unimplemented) PostGenericChargingProfileResult(w http.ResponseWriter, r *http.Request, uid string, params PostGenericChargingProfileResultParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (PUT /ocpi/2.2/sender/chargingprofiles/{sessionId})
func (_ Unimplemented) PutSenderChargingProfile(w http.ResponseWriter, r *http.Request, sessionId string, params PutSenderChargingProfileParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /ocpi/receiver/2.2/cdrs)
func (_ Unimplemented) PostClientOwnedCdr(w http.ResponseWriter, r *http.Request, params PostClientOwnedCdrParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /ocpi/receiver/2.2/cdrs/{cdrID})
func (_ Unimplemented) GetClientOwnedCdr(w http.ResponseWriter, r *http.Request, cdrID string, params GetClientOwnedCdrParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /ocpi/receiver/2.2/commands/CANCEL_RESERVATION)
func (_ Unimplemented) PostCancelReservation(w http.ResponseWriter, r *http.Request, params PostCancelReservationParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /ocpi/receiver/2.2/commands/RESERVE_NOW)
func (_ Unimplemented) PostReserveNow(w http.ResponseWriter, r *http.Request, params PostReserveNowParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /ocpi/receiver/2.2/commands/START_SESSION)
func (_ Unimplemented) PostStartSession(w http.ResponseWriter, r *http.Request, params PostStartSessionParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /ocpi/receiver/2.2/commands/STOP_SESSION)
func (_ Unimplemented) PostStopSession(w http.ResponseWriter, r *http.Request, params PostStopSessionParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /ocpi/receiver/2.2/commands/UNLOCK_CONNECTOR)
func (_ Unimplemented) PostUnlockConnector(w http.ResponseWriter, r *http.Request, params PostUnlockConnectorParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID})
func (_ Unimplemented) GetClientOwnedLocation(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, locationID string, params GetClientOwnedLocationParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (PATCH /ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID})
func (_ Unimplemented) PatchClientOwnedLocation(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, locationID string, params PatchClientOwnedLocationParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (PUT /ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID})
func (_ Unimplemented) PutClientOwnedLocation(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, locationID string, params PutClientOwnedLocationParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID}/{evseUID})
func (_ Unimplemented) GetClientOwnedEvse(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, locationID string, evseUID string, params GetClientOwnedEvseParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (PATCH /ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID}/{evseUID})
func (_ Unimplemented) PatchClientOwnedEvse(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, locationID string, evseUID string, params PatchClientOwnedEvseParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (PUT /ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID}/{evseUID})
func (_ Unimplemented) PutClientOwnedEvse(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, locationID string, evseUID string, params PutClientOwnedEvseParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID}/{evseUID}/{connectorID})
func (_ Unimplemented) GetClientOwnedConnector(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, locationID string, evseUID string, connectorID string, params GetClientOwnedConnectorParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (PATCH /ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID}/{evseUID}/{connectorID})
func (_ Unimplemented) PatchClientOwnedConnector(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, locationID string, evseUID string, connectorID string, params PatchClientOwnedConnectorParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (PUT /ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID}/{evseUID}/{connectorID})
func (_ Unimplemented) PutClientOwnedConnector(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, locationID string, evseUID string, connectorID string, params PutClientOwnedConnectorParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /ocpi/receiver/2.2/sessions/{countryCode}/{partyID}/{sessionID})
func (_ Unimplemented) GetClientOwnedSession(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, sessionID string, params GetClientOwnedSessionParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (PATCH /ocpi/receiver/2.2/sessions/{countryCode}/{partyID}/{sessionID})
func (_ Unimplemented) PatchClientOwnedSession(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, sessionID string, params PatchClientOwnedSessionParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (PUT /ocpi/receiver/2.2/sessions/{countryCode}/{partyID}/{sessionID})
func (_ Unimplemented) PutClientOwnedSession(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, sessionID string, params PutClientOwnedSessionParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (DELETE /ocpi/receiver/2.2/tariffs/{countryCode}/{partyID}/{tariffID})
func (_ Unimplemented) DeleteClientOwnedTariff(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, tariffID string, params DeleteClientOwnedTariffParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /ocpi/receiver/2.2/tariffs/{countryCode}/{partyID}/{tariffID})
func (_ Unimplemented) GetClientOwnedTariff(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, tariffID string, params GetClientOwnedTariffParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (PUT /ocpi/receiver/2.2/tariffs/{countryCode}/{partyID}/{tariffID})
func (_ Unimplemented) PutClientOwnedTariff(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, tariffID string, params PutClientOwnedTariffParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /ocpi/receiver/2.2/tokens/{countryCode}/{partyID}/{tokenUID})
func (_ Unimplemented) GetClientOwnedToken(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, tokenUID string, params GetClientOwnedTokenParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (PATCH /ocpi/receiver/2.2/tokens/{countryCode}/{partyID}/{tokenUID})
func (_ Unimplemented) PatchClientOwnedToken(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, tokenUID string, params PatchClientOwnedTokenParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (PUT /ocpi/receiver/2.2/tokens/{countryCode}/{partyID}/{tokenUID})
func (_ Unimplemented) PutClientOwnedToken(w http.ResponseWriter, r *http.Request, countryCode string, partyID string, tokenUID string, params PutClientOwnedTokenParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /ocpi/sender/2.2/cdrs)
func (_ Unimplemented) GetCdrsFromDataOwner(w http.ResponseWriter, r *http.Request, params GetCdrsFromDataOwnerParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /ocpi/sender/2.2/cdrs/page/{uid})
func (_ Unimplemented) GetCdrPageFromDataOwner(w http.ResponseWriter, r *http.Request, uid string, params GetCdrPageFromDataOwnerParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /ocpi/sender/2.2/commands/{command}/{uid})
func (_ Unimplemented) PostAsyncResponse(w http.ResponseWriter, r *http.Request, command PostAsyncResponseParamsCommand, uid string, params PostAsyncResponseParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /ocpi/sender/2.2/locations)
func (_ Unimplemented) GetLocationListFromDataOwner(w http.ResponseWriter, r *http.Request, params GetLocationListFromDataOwnerParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /ocpi/sender/2.2/locations/page/{uid})
func (_ Unimplemented) GetLocationPageFromDataOwner(w http.ResponseWriter, r *http.Request, uid string, params GetLocationPageFromDataOwnerParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /ocpi/sender/2.2/locations/{locationID})
func (_ Unimplemented) GetLocationObjectFromDataOwner(w http.ResponseWriter, r *http.Request, locationID string, params GetLocationObjectFromDataOwnerParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /ocpi/sender/2.2/locations/{locationID}/{evseUID})
func (_ Unimplemented) GetEvseObjectFromDataOwner(w http.ResponseWriter, r *http.Request, locationID string, evseUID string, params GetEvseObjectFromDataOwnerParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /ocpi/sender/2.2/locations/{locationID}/{evseUID}/{connectorID})
func (_ Unimplemented) GetConnectorObjectFromDataOwner(w http.ResponseWriter, r *http.Request, locationID string, evseUID string, connectorID string, params GetConnectorObjectFromDataOwnerParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /ocpi/sender/2.2/sessions)
func (_ Unimplemented) GetSessionsFromDataOwner(w http.ResponseWriter, r *http.Request, params GetSessionsFromDataOwnerParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /ocpi/sender/2.2/sessions/page/{uid})
func (_ Unimplemented) GetSessionsPageFromDataOwner(w http.ResponseWriter, r *http.Request, uid string, params GetSessionsPageFromDataOwnerParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (PUT /ocpi/sender/2.2/sessions/{sessionID}/charging_preferences)
func (_ Unimplemented) PutChargingPreferences(w http.ResponseWriter, r *http.Request, sessionID string, params PutChargingPreferencesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /ocpi/sender/2.2/tariffs)
func (_ Unimplemented) GetTariffsFromDataOwner(w http.ResponseWriter, r *http.Request, params GetTariffsFromDataOwnerParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /ocpi/sender/2.2/tariffs/page/{uid})
func (_ Unimplemented) GetTariffsPageFromDataOwner(w http.ResponseWriter, r *http.Request, uid string, params GetTariffsPageFromDataOwnerParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /ocpi/sender/2.2/tokens)
func (_ Unimplemented) GetTokensFromDataOwner(w http.ResponseWriter, r *http.Request, params GetTokensFromDataOwnerParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /ocpi/sender/2.2/tokens/page/{uid})
func (_ Unimplemented) GetTokensPageFromDataOwner(w http.ResponseWriter, r *http.Request, uid string, params GetTokensPageFromDataOwnerParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /ocpi/sender/2.2/tokens/{tokenUID}/authorize)
func (_ Unimplemented) PostRealTimeTokenAuthorization(w http.ResponseWriter, r *http.Request, tokenUID string, params PostRealTimeTokenAuthorizationParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (GET /ocpi/versions)
func (_ Unimplemented) GetVersions(w http.ResponseWriter, r *http.Request, params GetVersionsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetVersion operation middleware
func (siw *ServerInterfaceWrapper) GetVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetVersionParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetVersion(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteCredentials operation middleware
func (siw *ServerInterfaceWrapper) DeleteCredentials(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteCredentialsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteCredentials(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetCredentials operation middleware
func (siw *ServerInterfaceWrapper) GetCredentials(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCredentialsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCredentials(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostCredentials operation middleware
func (siw *ServerInterfaceWrapper) PostCredentials(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostCredentialsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostCredentials(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutCredentials operation middleware
func (siw *ServerInterfaceWrapper) PutCredentials(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutCredentialsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutCredentials(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteReceiverChargingProfile operation middleware
func (siw *ServerInterfaceWrapper) DeleteReceiverChargingProfile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "sessionId" -------------
	var sessionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "sessionId", runtime.ParamLocationPath, chi.URLParam(r, "sessionId"), &sessionId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sessionId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteReceiverChargingProfileParams

	// ------------- Required query parameter "response_url" -------------

	if paramValue := r.URL.Query().Get("response_url"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "response_url"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "response_url", r.URL.Query(), &params.ResponseUrl)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "response_url", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteReceiverChargingProfile(w, r, sessionId, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetReceiverChargingProfile operation middleware
func (siw *ServerInterfaceWrapper) GetReceiverChargingProfile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "sessionId" -------------
	var sessionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "sessionId", runtime.ParamLocationPath, chi.URLParam(r, "sessionId"), &sessionId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sessionId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetReceiverChargingProfileParams

	// ------------- Required query parameter "duration" -------------

	if paramValue := r.URL.Query().Get("duration"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "duration"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "duration", r.URL.Query(), &params.Duration)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "duration", Err: err})
		return
	}

	// ------------- Required query parameter "response_url" -------------

	if paramValue := r.URL.Query().Get("response_url"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "response_url"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "response_url", r.URL.Query(), &params.ResponseUrl)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "response_url", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetReceiverChargingProfile(w, r, sessionId, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutReceiverChargingProfile operation middleware
func (siw *ServerInterfaceWrapper) PutReceiverChargingProfile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "sessionId" -------------
	var sessionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "sessionId", runtime.ParamLocationPath, chi.URLParam(r, "sessionId"), &sessionId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sessionId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutReceiverChargingProfileParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutReceiverChargingProfile(w, r, sessionId, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostGenericChargingProfileResult operation middleware
func (siw *ServerInterfaceWrapper) PostGenericChargingProfileResult(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uid" -------------
	var uid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "uid", runtime.ParamLocationPath, chi.URLParam(r, "uid"), &uid)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uid", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostGenericChargingProfileResultParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGenericChargingProfileResult(w, r, uid, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutSenderChargingProfile operation middleware
func (siw *ServerInterfaceWrapper) PutSenderChargingProfile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "sessionId" -------------
	var sessionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "sessionId", runtime.ParamLocationPath, chi.URLParam(r, "sessionId"), &sessionId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sessionId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutSenderChargingProfileParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutSenderChargingProfile(w, r, sessionId, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostClientOwnedCdr operation middleware
func (siw *ServerInterfaceWrapper) PostClientOwnedCdr(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostClientOwnedCdrParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostClientOwnedCdr(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetClientOwnedCdr operation middleware
func (siw *ServerInterfaceWrapper) GetClientOwnedCdr(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "cdrID" -------------
	var cdrID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "cdrID", runtime.ParamLocationPath, chi.URLParam(r, "cdrID"), &cdrID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cdrID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetClientOwnedCdrParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetClientOwnedCdr(w, r, cdrID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostCancelReservation operation middleware
func (siw *ServerInterfaceWrapper) PostCancelReservation(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostCancelReservationParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostCancelReservation(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostReserveNow operation middleware
func (siw *ServerInterfaceWrapper) PostReserveNow(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostReserveNowParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostReserveNow(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostStartSession operation middleware
func (siw *ServerInterfaceWrapper) PostStartSession(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostStartSessionParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostStartSession(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostStopSession operation middleware
func (siw *ServerInterfaceWrapper) PostStopSession(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostStopSessionParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostStopSession(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostUnlockConnector operation middleware
func (siw *ServerInterfaceWrapper) PostUnlockConnector(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostUnlockConnectorParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostUnlockConnector(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetClientOwnedLocation operation middleware
func (siw *ServerInterfaceWrapper) GetClientOwnedLocation(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "countryCode" -------------
	var countryCode string

	err = runtime.BindStyledParameterWithLocation("simple", false, "countryCode", runtime.ParamLocationPath, chi.URLParam(r, "countryCode"), &countryCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "countryCode", Err: err})
		return
	}

	// ------------- Path parameter "partyID" -------------
	var partyID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "partyID", runtime.ParamLocationPath, chi.URLParam(r, "partyID"), &partyID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "partyID", Err: err})
		return
	}

	// ------------- Path parameter "locationID" -------------
	var locationID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "locationID", runtime.ParamLocationPath, chi.URLParam(r, "locationID"), &locationID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "locationID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetClientOwnedLocationParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetClientOwnedLocation(w, r, countryCode, partyID, locationID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PatchClientOwnedLocation operation middleware
func (siw *ServerInterfaceWrapper) PatchClientOwnedLocation(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "countryCode" -------------
	var countryCode string

	err = runtime.BindStyledParameterWithLocation("simple", false, "countryCode", runtime.ParamLocationPath, chi.URLParam(r, "countryCode"), &countryCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "countryCode", Err: err})
		return
	}

	// ------------- Path parameter "partyID" -------------
	var partyID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "partyID", runtime.ParamLocationPath, chi.URLParam(r, "partyID"), &partyID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "partyID", Err: err})
		return
	}

	// ------------- Path parameter "locationID" -------------
	var locationID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "locationID", runtime.ParamLocationPath, chi.URLParam(r, "locationID"), &locationID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "locationID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchClientOwnedLocationParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PatchClientOwnedLocation(w, r, countryCode, partyID, locationID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutClientOwnedLocation operation middleware
func (siw *ServerInterfaceWrapper) PutClientOwnedLocation(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "countryCode" -------------
	var countryCode string

	err = runtime.BindStyledParameterWithLocation("simple", false, "countryCode", runtime.ParamLocationPath, chi.URLParam(r, "countryCode"), &countryCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "countryCode", Err: err})
		return
	}

	// ------------- Path parameter "partyID" -------------
	var partyID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "partyID", runtime.ParamLocationPath, chi.URLParam(r, "partyID"), &partyID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "partyID", Err: err})
		return
	}

	// ------------- Path parameter "locationID" -------------
	var locationID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "locationID", runtime.ParamLocationPath, chi.URLParam(r, "locationID"), &locationID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "locationID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutClientOwnedLocationParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutClientOwnedLocation(w, r, countryCode, partyID, locationID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetClientOwnedEvse operation middleware
func (siw *ServerInterfaceWrapper) GetClientOwnedEvse(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "countryCode" -------------
	var countryCode string

	err = runtime.BindStyledParameterWithLocation("simple", false, "countryCode", runtime.ParamLocationPath, chi.URLParam(r, "countryCode"), &countryCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "countryCode", Err: err})
		return
	}

	// ------------- Path parameter "partyID" -------------
	var partyID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "partyID", runtime.ParamLocationPath, chi.URLParam(r, "partyID"), &partyID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "partyID", Err: err})
		return
	}

	// ------------- Path parameter "locationID" -------------
	var locationID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "locationID", runtime.ParamLocationPath, chi.URLParam(r, "locationID"), &locationID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "locationID", Err: err})
		return
	}

	// ------------- Path parameter "evseUID" -------------
	var evseUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "evseUID", runtime.ParamLocationPath, chi.URLParam(r, "evseUID"), &evseUID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "evseUID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetClientOwnedEvseParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetClientOwnedEvse(w, r, countryCode, partyID, locationID, evseUID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PatchClientOwnedEvse operation middleware
func (siw *ServerInterfaceWrapper) PatchClientOwnedEvse(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "countryCode" -------------
	var countryCode string

	err = runtime.BindStyledParameterWithLocation("simple", false, "countryCode", runtime.ParamLocationPath, chi.URLParam(r, "countryCode"), &countryCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "countryCode", Err: err})
		return
	}

	// ------------- Path parameter "partyID" -------------
	var partyID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "partyID", runtime.ParamLocationPath, chi.URLParam(r, "partyID"), &partyID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "partyID", Err: err})
		return
	}

	// ------------- Path parameter "locationID" -------------
	var locationID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "locationID", runtime.ParamLocationPath, chi.URLParam(r, "locationID"), &locationID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "locationID", Err: err})
		return
	}

	// ------------- Path parameter "evseUID" -------------
	var evseUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "evseUID", runtime.ParamLocationPath, chi.URLParam(r, "evseUID"), &evseUID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "evseUID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchClientOwnedEvseParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PatchClientOwnedEvse(w, r, countryCode, partyID, locationID, evseUID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutClientOwnedEvse operation middleware
func (siw *ServerInterfaceWrapper) PutClientOwnedEvse(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "countryCode" -------------
	var countryCode string

	err = runtime.BindStyledParameterWithLocation("simple", false, "countryCode", runtime.ParamLocationPath, chi.URLParam(r, "countryCode"), &countryCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "countryCode", Err: err})
		return
	}

	// ------------- Path parameter "partyID" -------------
	var partyID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "partyID", runtime.ParamLocationPath, chi.URLParam(r, "partyID"), &partyID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "partyID", Err: err})
		return
	}

	// ------------- Path parameter "locationID" -------------
	var locationID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "locationID", runtime.ParamLocationPath, chi.URLParam(r, "locationID"), &locationID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "locationID", Err: err})
		return
	}

	// ------------- Path parameter "evseUID" -------------
	var evseUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "evseUID", runtime.ParamLocationPath, chi.URLParam(r, "evseUID"), &evseUID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "evseUID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutClientOwnedEvseParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutClientOwnedEvse(w, r, countryCode, partyID, locationID, evseUID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetClientOwnedConnector operation middleware
func (siw *ServerInterfaceWrapper) GetClientOwnedConnector(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "countryCode" -------------
	var countryCode string

	err = runtime.BindStyledParameterWithLocation("simple", false, "countryCode", runtime.ParamLocationPath, chi.URLParam(r, "countryCode"), &countryCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "countryCode", Err: err})
		return
	}

	// ------------- Path parameter "partyID" -------------
	var partyID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "partyID", runtime.ParamLocationPath, chi.URLParam(r, "partyID"), &partyID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "partyID", Err: err})
		return
	}

	// ------------- Path parameter "locationID" -------------
	var locationID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "locationID", runtime.ParamLocationPath, chi.URLParam(r, "locationID"), &locationID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "locationID", Err: err})
		return
	}

	// ------------- Path parameter "evseUID" -------------
	var evseUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "evseUID", runtime.ParamLocationPath, chi.URLParam(r, "evseUID"), &evseUID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "evseUID", Err: err})
		return
	}

	// ------------- Path parameter "connectorID" -------------
	var connectorID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "connectorID", runtime.ParamLocationPath, chi.URLParam(r, "connectorID"), &connectorID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "connectorID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetClientOwnedConnectorParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetClientOwnedConnector(w, r, countryCode, partyID, locationID, evseUID, connectorID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PatchClientOwnedConnector operation middleware
func (siw *ServerInterfaceWrapper) PatchClientOwnedConnector(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "countryCode" -------------
	var countryCode string

	err = runtime.BindStyledParameterWithLocation("simple", false, "countryCode", runtime.ParamLocationPath, chi.URLParam(r, "countryCode"), &countryCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "countryCode", Err: err})
		return
	}

	// ------------- Path parameter "partyID" -------------
	var partyID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "partyID", runtime.ParamLocationPath, chi.URLParam(r, "partyID"), &partyID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "partyID", Err: err})
		return
	}

	// ------------- Path parameter "locationID" -------------
	var locationID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "locationID", runtime.ParamLocationPath, chi.URLParam(r, "locationID"), &locationID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "locationID", Err: err})
		return
	}

	// ------------- Path parameter "evseUID" -------------
	var evseUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "evseUID", runtime.ParamLocationPath, chi.URLParam(r, "evseUID"), &evseUID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "evseUID", Err: err})
		return
	}

	// ------------- Path parameter "connectorID" -------------
	var connectorID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "connectorID", runtime.ParamLocationPath, chi.URLParam(r, "connectorID"), &connectorID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "connectorID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchClientOwnedConnectorParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PatchClientOwnedConnector(w, r, countryCode, partyID, locationID, evseUID, connectorID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutClientOwnedConnector operation middleware
func (siw *ServerInterfaceWrapper) PutClientOwnedConnector(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "countryCode" -------------
	var countryCode string

	err = runtime.BindStyledParameterWithLocation("simple", false, "countryCode", runtime.ParamLocationPath, chi.URLParam(r, "countryCode"), &countryCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "countryCode", Err: err})
		return
	}

	// ------------- Path parameter "partyID" -------------
	var partyID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "partyID", runtime.ParamLocationPath, chi.URLParam(r, "partyID"), &partyID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "partyID", Err: err})
		return
	}

	// ------------- Path parameter "locationID" -------------
	var locationID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "locationID", runtime.ParamLocationPath, chi.URLParam(r, "locationID"), &locationID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "locationID", Err: err})
		return
	}

	// ------------- Path parameter "evseUID" -------------
	var evseUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "evseUID", runtime.ParamLocationPath, chi.URLParam(r, "evseUID"), &evseUID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "evseUID", Err: err})
		return
	}

	// ------------- Path parameter "connectorID" -------------
	var connectorID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "connectorID", runtime.ParamLocationPath, chi.URLParam(r, "connectorID"), &connectorID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "connectorID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutClientOwnedConnectorParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutClientOwnedConnector(w, r, countryCode, partyID, locationID, evseUID, connectorID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetClientOwnedSession operation middleware
func (siw *ServerInterfaceWrapper) GetClientOwnedSession(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "countryCode" -------------
	var countryCode string

	err = runtime.BindStyledParameterWithLocation("simple", false, "countryCode", runtime.ParamLocationPath, chi.URLParam(r, "countryCode"), &countryCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "countryCode", Err: err})
		return
	}

	// ------------- Path parameter "partyID" -------------
	var partyID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "partyID", runtime.ParamLocationPath, chi.URLParam(r, "partyID"), &partyID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "partyID", Err: err})
		return
	}

	// ------------- Path parameter "sessionID" -------------
	var sessionID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "sessionID", runtime.ParamLocationPath, chi.URLParam(r, "sessionID"), &sessionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sessionID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetClientOwnedSessionParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetClientOwnedSession(w, r, countryCode, partyID, sessionID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PatchClientOwnedSession operation middleware
func (siw *ServerInterfaceWrapper) PatchClientOwnedSession(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "countryCode" -------------
	var countryCode string

	err = runtime.BindStyledParameterWithLocation("simple", false, "countryCode", runtime.ParamLocationPath, chi.URLParam(r, "countryCode"), &countryCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "countryCode", Err: err})
		return
	}

	// ------------- Path parameter "partyID" -------------
	var partyID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "partyID", runtime.ParamLocationPath, chi.URLParam(r, "partyID"), &partyID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "partyID", Err: err})
		return
	}

	// ------------- Path parameter "sessionID" -------------
	var sessionID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "sessionID", runtime.ParamLocationPath, chi.URLParam(r, "sessionID"), &sessionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sessionID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchClientOwnedSessionParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PatchClientOwnedSession(w, r, countryCode, partyID, sessionID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutClientOwnedSession operation middleware
func (siw *ServerInterfaceWrapper) PutClientOwnedSession(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "countryCode" -------------
	var countryCode string

	err = runtime.BindStyledParameterWithLocation("simple", false, "countryCode", runtime.ParamLocationPath, chi.URLParam(r, "countryCode"), &countryCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "countryCode", Err: err})
		return
	}

	// ------------- Path parameter "partyID" -------------
	var partyID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "partyID", runtime.ParamLocationPath, chi.URLParam(r, "partyID"), &partyID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "partyID", Err: err})
		return
	}

	// ------------- Path parameter "sessionID" -------------
	var sessionID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "sessionID", runtime.ParamLocationPath, chi.URLParam(r, "sessionID"), &sessionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sessionID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutClientOwnedSessionParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutClientOwnedSession(w, r, countryCode, partyID, sessionID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteClientOwnedTariff operation middleware
func (siw *ServerInterfaceWrapper) DeleteClientOwnedTariff(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "countryCode" -------------
	var countryCode string

	err = runtime.BindStyledParameterWithLocation("simple", false, "countryCode", runtime.ParamLocationPath, chi.URLParam(r, "countryCode"), &countryCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "countryCode", Err: err})
		return
	}

	// ------------- Path parameter "partyID" -------------
	var partyID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "partyID", runtime.ParamLocationPath, chi.URLParam(r, "partyID"), &partyID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "partyID", Err: err})
		return
	}

	// ------------- Path parameter "tariffID" -------------
	var tariffID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "tariffID", runtime.ParamLocationPath, chi.URLParam(r, "tariffID"), &tariffID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tariffID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteClientOwnedTariffParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteClientOwnedTariff(w, r, countryCode, partyID, tariffID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetClientOwnedTariff operation middleware
func (siw *ServerInterfaceWrapper) GetClientOwnedTariff(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "countryCode" -------------
	var countryCode string

	err = runtime.BindStyledParameterWithLocation("simple", false, "countryCode", runtime.ParamLocationPath, chi.URLParam(r, "countryCode"), &countryCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "countryCode", Err: err})
		return
	}

	// ------------- Path parameter "partyID" -------------
	var partyID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "partyID", runtime.ParamLocationPath, chi.URLParam(r, "partyID"), &partyID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "partyID", Err: err})
		return
	}

	// ------------- Path parameter "tariffID" -------------
	var tariffID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "tariffID", runtime.ParamLocationPath, chi.URLParam(r, "tariffID"), &tariffID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tariffID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetClientOwnedTariffParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetClientOwnedTariff(w, r, countryCode, partyID, tariffID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutClientOwnedTariff operation middleware
func (siw *ServerInterfaceWrapper) PutClientOwnedTariff(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "countryCode" -------------
	var countryCode string

	err = runtime.BindStyledParameterWithLocation("simple", false, "countryCode", runtime.ParamLocationPath, chi.URLParam(r, "countryCode"), &countryCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "countryCode", Err: err})
		return
	}

	// ------------- Path parameter "partyID" -------------
	var partyID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "partyID", runtime.ParamLocationPath, chi.URLParam(r, "partyID"), &partyID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "partyID", Err: err})
		return
	}

	// ------------- Path parameter "tariffID" -------------
	var tariffID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "tariffID", runtime.ParamLocationPath, chi.URLParam(r, "tariffID"), &tariffID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tariffID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutClientOwnedTariffParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutClientOwnedTariff(w, r, countryCode, partyID, tariffID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetClientOwnedToken operation middleware
func (siw *ServerInterfaceWrapper) GetClientOwnedToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "countryCode" -------------
	var countryCode string

	err = runtime.BindStyledParameterWithLocation("simple", false, "countryCode", runtime.ParamLocationPath, chi.URLParam(r, "countryCode"), &countryCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "countryCode", Err: err})
		return
	}

	// ------------- Path parameter "partyID" -------------
	var partyID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "partyID", runtime.ParamLocationPath, chi.URLParam(r, "partyID"), &partyID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "partyID", Err: err})
		return
	}

	// ------------- Path parameter "tokenUID" -------------
	var tokenUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "tokenUID", runtime.ParamLocationPath, chi.URLParam(r, "tokenUID"), &tokenUID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tokenUID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetClientOwnedTokenParams

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", r.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetClientOwnedToken(w, r, countryCode, partyID, tokenUID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PatchClientOwnedToken operation middleware
func (siw *ServerInterfaceWrapper) PatchClientOwnedToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "countryCode" -------------
	var countryCode string

	err = runtime.BindStyledParameterWithLocation("simple", false, "countryCode", runtime.ParamLocationPath, chi.URLParam(r, "countryCode"), &countryCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "countryCode", Err: err})
		return
	}

	// ------------- Path parameter "partyID" -------------
	var partyID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "partyID", runtime.ParamLocationPath, chi.URLParam(r, "partyID"), &partyID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "partyID", Err: err})
		return
	}

	// ------------- Path parameter "tokenUID" -------------
	var tokenUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "tokenUID", runtime.ParamLocationPath, chi.URLParam(r, "tokenUID"), &tokenUID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tokenUID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchClientOwnedTokenParams

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", r.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PatchClientOwnedToken(w, r, countryCode, partyID, tokenUID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutClientOwnedToken operation middleware
func (siw *ServerInterfaceWrapper) PutClientOwnedToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "countryCode" -------------
	var countryCode string

	err = runtime.BindStyledParameterWithLocation("simple", false, "countryCode", runtime.ParamLocationPath, chi.URLParam(r, "countryCode"), &countryCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "countryCode", Err: err})
		return
	}

	// ------------- Path parameter "partyID" -------------
	var partyID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "partyID", runtime.ParamLocationPath, chi.URLParam(r, "partyID"), &partyID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "partyID", Err: err})
		return
	}

	// ------------- Path parameter "tokenUID" -------------
	var tokenUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "tokenUID", runtime.ParamLocationPath, chi.URLParam(r, "tokenUID"), &tokenUID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tokenUID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutClientOwnedTokenParams

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", r.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutClientOwnedToken(w, r, countryCode, partyID, tokenUID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetCdrsFromDataOwner operation middleware
func (siw *ServerInterfaceWrapper) GetCdrsFromDataOwner(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCdrsFromDataOwnerParams

	// ------------- Optional query parameter "date_from" -------------

	err = runtime.BindQueryParameter("form", true, false, "date_from", r.URL.Query(), &params.DateFrom)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date_from", Err: err})
		return
	}

	// ------------- Optional query parameter "date_to" -------------

	err = runtime.BindQueryParameter("form", true, false, "date_to", r.URL.Query(), &params.DateTo)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date_to", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCdrsFromDataOwner(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetCdrPageFromDataOwner operation middleware
func (siw *ServerInterfaceWrapper) GetCdrPageFromDataOwner(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uid" -------------
	var uid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "uid", runtime.ParamLocationPath, chi.URLParam(r, "uid"), &uid)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uid", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCdrPageFromDataOwnerParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCdrPageFromDataOwner(w, r, uid, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostAsyncResponse operation middleware
func (siw *ServerInterfaceWrapper) PostAsyncResponse(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "command" -------------
	var command PostAsyncResponseParamsCommand

	err = runtime.BindStyledParameterWithLocation("simple", false, "command", runtime.ParamLocationPath, chi.URLParam(r, "command"), &command)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "command", Err: err})
		return
	}

	// ------------- Path parameter "uid" -------------
	var uid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "uid", runtime.ParamLocationPath, chi.URLParam(r, "uid"), &uid)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uid", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAsyncResponseParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAsyncResponse(w, r, command, uid, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetLocationListFromDataOwner operation middleware
func (siw *ServerInterfaceWrapper) GetLocationListFromDataOwner(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLocationListFromDataOwnerParams

	// ------------- Optional query parameter "date_from" -------------

	err = runtime.BindQueryParameter("form", true, false, "date_from", r.URL.Query(), &params.DateFrom)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date_from", Err: err})
		return
	}

	// ------------- Optional query parameter "date_to" -------------

	err = runtime.BindQueryParameter("form", true, false, "date_to", r.URL.Query(), &params.DateTo)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date_to", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLocationListFromDataOwner(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetLocationPageFromDataOwner operation middleware
func (siw *ServerInterfaceWrapper) GetLocationPageFromDataOwner(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uid" -------------
	var uid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "uid", runtime.ParamLocationPath, chi.URLParam(r, "uid"), &uid)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uid", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLocationPageFromDataOwnerParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLocationPageFromDataOwner(w, r, uid, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetLocationObjectFromDataOwner operation middleware
func (siw *ServerInterfaceWrapper) GetLocationObjectFromDataOwner(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "locationID" -------------
	var locationID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "locationID", runtime.ParamLocationPath, chi.URLParam(r, "locationID"), &locationID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "locationID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLocationObjectFromDataOwnerParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLocationObjectFromDataOwner(w, r, locationID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetEvseObjectFromDataOwner operation middleware
func (siw *ServerInterfaceWrapper) GetEvseObjectFromDataOwner(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "locationID" -------------
	var locationID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "locationID", runtime.ParamLocationPath, chi.URLParam(r, "locationID"), &locationID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "locationID", Err: err})
		return
	}

	// ------------- Path parameter "evseUID" -------------
	var evseUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "evseUID", runtime.ParamLocationPath, chi.URLParam(r, "evseUID"), &evseUID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "evseUID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEvseObjectFromDataOwnerParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetEvseObjectFromDataOwner(w, r, locationID, evseUID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetConnectorObjectFromDataOwner operation middleware
func (siw *ServerInterfaceWrapper) GetConnectorObjectFromDataOwner(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "locationID" -------------
	var locationID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "locationID", runtime.ParamLocationPath, chi.URLParam(r, "locationID"), &locationID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "locationID", Err: err})
		return
	}

	// ------------- Path parameter "evseUID" -------------
	var evseUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "evseUID", runtime.ParamLocationPath, chi.URLParam(r, "evseUID"), &evseUID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "evseUID", Err: err})
		return
	}

	// ------------- Path parameter "connectorID" -------------
	var connectorID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "connectorID", runtime.ParamLocationPath, chi.URLParam(r, "connectorID"), &connectorID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "connectorID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetConnectorObjectFromDataOwnerParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetConnectorObjectFromDataOwner(w, r, locationID, evseUID, connectorID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSessionsFromDataOwner operation middleware
func (siw *ServerInterfaceWrapper) GetSessionsFromDataOwner(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSessionsFromDataOwnerParams

	// ------------- Optional query parameter "date_from" -------------

	err = runtime.BindQueryParameter("form", true, false, "date_from", r.URL.Query(), &params.DateFrom)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date_from", Err: err})
		return
	}

	// ------------- Optional query parameter "date_to" -------------

	err = runtime.BindQueryParameter("form", true, false, "date_to", r.URL.Query(), &params.DateTo)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date_to", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSessionsFromDataOwner(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSessionsPageFromDataOwner operation middleware
func (siw *ServerInterfaceWrapper) GetSessionsPageFromDataOwner(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uid" -------------
	var uid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "uid", runtime.ParamLocationPath, chi.URLParam(r, "uid"), &uid)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uid", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSessionsPageFromDataOwnerParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSessionsPageFromDataOwner(w, r, uid, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutChargingPreferences operation middleware
func (siw *ServerInterfaceWrapper) PutChargingPreferences(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "sessionID" -------------
	var sessionID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "sessionID", runtime.ParamLocationPath, chi.URLParam(r, "sessionID"), &sessionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sessionID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutChargingPreferencesParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutChargingPreferences(w, r, sessionID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetTariffsFromDataOwner operation middleware
func (siw *ServerInterfaceWrapper) GetTariffsFromDataOwner(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTariffsFromDataOwnerParams

	// ------------- Optional query parameter "date_from" -------------

	err = runtime.BindQueryParameter("form", true, false, "date_from", r.URL.Query(), &params.DateFrom)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date_from", Err: err})
		return
	}

	// ------------- Optional query parameter "date_to" -------------

	err = runtime.BindQueryParameter("form", true, false, "date_to", r.URL.Query(), &params.DateTo)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date_to", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTariffsFromDataOwner(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetTariffsPageFromDataOwner operation middleware
func (siw *ServerInterfaceWrapper) GetTariffsPageFromDataOwner(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uid" -------------
	var uid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "uid", runtime.ParamLocationPath, chi.URLParam(r, "uid"), &uid)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uid", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTariffsPageFromDataOwnerParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTariffsPageFromDataOwner(w, r, uid, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetTokensFromDataOwner operation middleware
func (siw *ServerInterfaceWrapper) GetTokensFromDataOwner(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTokensFromDataOwnerParams

	// ------------- Optional query parameter "date_from" -------------

	err = runtime.BindQueryParameter("form", true, false, "date_from", r.URL.Query(), &params.DateFrom)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date_from", Err: err})
		return
	}

	// ------------- Optional query parameter "date_to" -------------

	err = runtime.BindQueryParameter("form", true, false, "date_to", r.URL.Query(), &params.DateTo)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date_to", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTokensFromDataOwner(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetTokensPageFromDataOwner operation middleware
func (siw *ServerInterfaceWrapper) GetTokensPageFromDataOwner(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uid" -------------
	var uid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "uid", runtime.ParamLocationPath, chi.URLParam(r, "uid"), &uid)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uid", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTokensPageFromDataOwnerParams

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTokensPageFromDataOwner(w, r, uid, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostRealTimeTokenAuthorization operation middleware
func (siw *ServerInterfaceWrapper) PostRealTimeTokenAuthorization(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "tokenUID" -------------
	var tokenUID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "tokenUID", runtime.ParamLocationPath, chi.URLParam(r, "tokenUID"), &tokenUID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tokenUID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostRealTimeTokenAuthorizationParams

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", r.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "authorization", Err: err})
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, valueList[0], &XRequestID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = XRequestID

	} else {
		err := fmt.Errorf("Header parameter X-Request-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Request-ID", Err: err})
		return
	}

	// ------------- Required header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, valueList[0], &XCorrelationID)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-ID", Err: err})
			return
		}

		params.XCorrelationID = XCorrelationID

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-ID", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-country-code")]; found {
		var OCPIFromCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIFromCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-country-code", Err: err})
			return
		}

		params.OCPIFromCountryCode = OCPIFromCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-from-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-from-party-id")]; found {
		var OCPIFromPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-from-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-from-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIFromPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-from-party-id", Err: err})
			return
		}

		params.OCPIFromPartyId = OCPIFromPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-from-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-from-party-id", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-country-code" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-country-code")]; found {
		var OCPIToCountryCode string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-country-code", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-country-code", runtime.ParamLocationHeader, valueList[0], &OCPIToCountryCode)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-country-code", Err: err})
			return
		}

		params.OCPIToCountryCode = OCPIToCountryCode

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-country-code is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-country-code", Err: err})
		return
	}

	// ------------- Required header parameter "OCPI-to-party-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("OCPI-to-party-id")]; found {
		var OCPIToPartyId string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "OCPI-to-party-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "OCPI-to-party-id", runtime.ParamLocationHeader, valueList[0], &OCPIToPartyId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "OCPI-to-party-id", Err: err})
			return
		}

		params.OCPIToPartyId = OCPIToPartyId

	} else {
		err := fmt.Errorf("Header parameter OCPI-to-party-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "OCPI-to-party-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostRealTimeTokenAuthorization(w, r, tokenUID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetVersions operation middleware
func (siw *ServerInterfaceWrapper) GetVersions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetVersionsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetVersions(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ocpi/2.2", wrapper.GetVersion)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/ocpi/2.2/credentials", wrapper.DeleteCredentials)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ocpi/2.2/credentials", wrapper.GetCredentials)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/ocpi/2.2/credentials", wrapper.PostCredentials)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/ocpi/2.2/credentials", wrapper.PutCredentials)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/ocpi/2.2/receiver/chargingprofiles/{sessionId}", wrapper.DeleteReceiverChargingProfile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ocpi/2.2/receiver/chargingprofiles/{sessionId}", wrapper.GetReceiverChargingProfile)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/ocpi/2.2/receiver/chargingprofiles/{sessionId}", wrapper.PutReceiverChargingProfile)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/ocpi/2.2/sender/chargingprofiles/result/{uid}", wrapper.PostGenericChargingProfileResult)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/ocpi/2.2/sender/chargingprofiles/{sessionId}", wrapper.PutSenderChargingProfile)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/ocpi/receiver/2.2/cdrs", wrapper.PostClientOwnedCdr)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ocpi/receiver/2.2/cdrs/{cdrID}", wrapper.GetClientOwnedCdr)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/ocpi/receiver/2.2/commands/CANCEL_RESERVATION", wrapper.PostCancelReservation)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/ocpi/receiver/2.2/commands/RESERVE_NOW", wrapper.PostReserveNow)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/ocpi/receiver/2.2/commands/START_SESSION", wrapper.PostStartSession)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/ocpi/receiver/2.2/commands/STOP_SESSION", wrapper.PostStopSession)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/ocpi/receiver/2.2/commands/UNLOCK_CONNECTOR", wrapper.PostUnlockConnector)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID}", wrapper.GetClientOwnedLocation)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID}", wrapper.PatchClientOwnedLocation)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID}", wrapper.PutClientOwnedLocation)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID}/{evseUID}", wrapper.GetClientOwnedEvse)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID}/{evseUID}", wrapper.PatchClientOwnedEvse)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID}/{evseUID}", wrapper.PutClientOwnedEvse)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID}/{evseUID}/{connectorID}", wrapper.GetClientOwnedConnector)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID}/{evseUID}/{connectorID}", wrapper.PatchClientOwnedConnector)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/ocpi/receiver/2.2/locations/{countryCode}/{partyID}/{locationID}/{evseUID}/{connectorID}", wrapper.PutClientOwnedConnector)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ocpi/receiver/2.2/sessions/{countryCode}/{partyID}/{sessionID}", wrapper.GetClientOwnedSession)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/ocpi/receiver/2.2/sessions/{countryCode}/{partyID}/{sessionID}", wrapper.PatchClientOwnedSession)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/ocpi/receiver/2.2/sessions/{countryCode}/{partyID}/{sessionID}", wrapper.PutClientOwnedSession)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/ocpi/receiver/2.2/tariffs/{countryCode}/{partyID}/{tariffID}", wrapper.DeleteClientOwnedTariff)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ocpi/receiver/2.2/tariffs/{countryCode}/{partyID}/{tariffID}", wrapper.GetClientOwnedTariff)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/ocpi/receiver/2.2/tariffs/{countryCode}/{partyID}/{tariffID}", wrapper.PutClientOwnedTariff)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ocpi/receiver/2.2/tokens/{countryCode}/{partyID}/{tokenUID}", wrapper.GetClientOwnedToken)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/ocpi/receiver/2.2/tokens/{countryCode}/{partyID}/{tokenUID}", wrapper.PatchClientOwnedToken)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/ocpi/receiver/2.2/tokens/{countryCode}/{partyID}/{tokenUID}", wrapper.PutClientOwnedToken)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ocpi/sender/2.2/cdrs", wrapper.GetCdrsFromDataOwner)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ocpi/sender/2.2/cdrs/page/{uid}", wrapper.GetCdrPageFromDataOwner)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/ocpi/sender/2.2/commands/{command}/{uid}", wrapper.PostAsyncResponse)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ocpi/sender/2.2/locations", wrapper.GetLocationListFromDataOwner)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ocpi/sender/2.2/locations/page/{uid}", wrapper.GetLocationPageFromDataOwner)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ocpi/sender/2.2/locations/{locationID}", wrapper.GetLocationObjectFromDataOwner)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ocpi/sender/2.2/locations/{locationID}/{evseUID}", wrapper.GetEvseObjectFromDataOwner)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ocpi/sender/2.2/locations/{locationID}/{evseUID}/{connectorID}", wrapper.GetConnectorObjectFromDataOwner)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ocpi/sender/2.2/sessions", wrapper.GetSessionsFromDataOwner)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ocpi/sender/2.2/sessions/page/{uid}", wrapper.GetSessionsPageFromDataOwner)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/ocpi/sender/2.2/sessions/{sessionID}/charging_preferences", wrapper.PutChargingPreferences)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ocpi/sender/2.2/tariffs", wrapper.GetTariffsFromDataOwner)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ocpi/sender/2.2/tariffs/page/{uid}", wrapper.GetTariffsPageFromDataOwner)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ocpi/sender/2.2/tokens", wrapper.GetTokensFromDataOwner)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ocpi/sender/2.2/tokens/page/{uid}", wrapper.GetTokensPageFromDataOwner)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/ocpi/sender/2.2/tokens/{tokenUID}/authorize", wrapper.PostRealTimeTokenAuthorization)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/ocpi/versions", wrapper.GetVersions)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9b3OjOBL3V6H8PC/urpzxzOze1l3eMZgk3DjGD8bJTO1OUQootm4weIVwJjeV7/6U",
	"hMACxB87yUyc1ZsEDBKtlvqn7lar9X3gx+tNHMGIJIPT74PEX8E1YJe6T9AWGiuAlyhaznB8i0JIH2xw",
	"vIGYIMhe8/kL3mb3xv/F8HZwOvg/o13lI17zqFrhw3CQEICJFwACPYLWrAZyv4GD00FCMIqWg4eH4QDD",
	"P1OEYTA4/b3+zXodX4Z5HfHNf6FP6Hf0IEAExREIz2E8iX1Ab+otCgFBJA1kdAwHYRwtm59GYN3JgDFK",
	"NiG4d+E3UmtY8WnxQ9KmpGQVY/Q/1gQruo3rzQBhGN/Rar8PYJSuafX6ZGJfm+PBcPBhYhsf2ZX5aWY5",
	"7Gpqe4Zjji2XXbte/vbu+7uGAvH7Hoa3EMPIlzMFcfJ6M4U2ftc5bcXyTnRyAhJamsRfYWdRl71U7YCc",
	"aXklMt5/SBMUwSQZQwJQmEgGULzsbLC1BksoDpka2+7gTYJID2lgNcgINcaOZFikZOWtIVnF5aGxcC88",
	"x/x/C3NO+9+wLy/1KR0V1xeWa06sufvoceAH2OvbsUaACwHlRXv1qhFg3rFDASUgRnHAWo8IXCe9IYqV",
	"YyMqawvAGNyzquM0Ivje8+MGIPAxDBARHt3EcQhBtHu2Y5aHAnkdKabP76UPYRS0IuZw0FArirYx8mH3",
	"50OQEC/d0I/IX1hDAnFT6Q3A5L7pIYZrgL9KHyUwSehQaiiZoGUEWctBVy/O2atj+mavOWY4IACj29v+",
	"48Rl78vGB4kJCD0/TkhXHTOMfLgrAiOIl6zHb2O8BmRwOrgNY0AGxTeidH0DcbXEId+6Rd9gcEjBDcBf",
	"qVw9omjeB31biWEC8TZDmQM+u+/n6Pv7fKc6iwgYW8E9EcskEFWBFgEEqiLPBLwipYLY1Ud8aVRWxluJ",
	"T9KpBEQ+DJ1dL9QnFrGLGuU+2cRRAr0Uh93zWqXCSnEplQEeozWMEimB2eu7Kc9YOI45pbOdOTWd88/F",
	"hWd+mtnO7oFnXfL7S/2Ttyt2aU3FO/2TN7OvTYc/ya9nuvPRmp57rnVp0lv+s2POTedKdy17mj+au7pr",
	"evaZZ1zozjn9hT2QzbvbOEz7DekKU9nTonwDE5t1YxAEGCaJfL5CRD5X+XEUQZ/E2MuJ3XXCnOqhTOPQ",
	"P0zkbd0Vb5ooixc28R3EXrWjdcN7580u9DllqW54vxQ3Y6PjiwkBUQBwSVUyLvSxeWnT4valOXctw9PF",
	"mw/ijSHejMUbU7w5E2/OxZsL8cYSb/4j3nwUbyaD4cAyDe+3t7+8/bf33ktQtAyh9+63yu9khWHjz7+8",
	"l/7826/5z+/f/fs3z31XufUM+/KDXf7xfeVW9s4veuXeYLIzde1zR59deB9s17UvvcWs/LNrz7yxfT2l",
	"wmLOJ7rnFFfzhr6NcYAiQGDn/C5aiTulT66ObZNGRYo9S5vUsaDVkKzrVXGSgXjQwzLIpZXLpkQSK9LV",
	"IEtSiSizcseeHTOEpvPZSqS+AXvcXM2vuBniiGDgkyYm12R+7F3YhreYM7DVZ7P80nYvMvw9s+Smrbyn",
	"qh4IgZxhDqq0pLRVZXui1rYgn7P2MFHEmU6igPZXd70+zRUo7Odq2Xl5dpZ5vd2QqispbqExQAnTkaAn",
	"uDPqJhVXgiOYvdCt5nHHUW2qMC5MnSLMmc7M4HPHNKdssj5fTHRHMl4qjCrV286Ynv40rhrub7xmxVts",
	"2PxDmPZkGqHSvHxNpUYqH0GKC+WgYDSKCJsv+NsoInCZcXqNIq/0qX4ddLhPcNecHvxvEskQrTN+9KV0",
	"10udPKn6/NinKvX0IN3h2rBUE09DUtaADHPmci+f680XM6rQsnvH/I9pZJeubXv2mctG/GL6cWpfT725",
	"OZ9b9lQ6EmjHxCk5pNGcxF0d0gbH6zWIguaGrmGSgCXc07lYZ08LTwTOvSyW8CY8D0OEVhv61DAn5tgT",
	"DBZqGV3NTc82jMXMytzI9N6a2jPT0V3rymQYak06h5x1adoLV+Cu+JlOuOWUyznFNZY6lw6yQg72koFv",
	"HlhvIOb90gcywTcPhtAnGPmZGrZHwW0ckv6feiKDqd1MMi50+z/WC7eXzj+4nm7wi7HxWiyoqXmpe//0",
	"3r/Nr3/zfhGu/1lcv3srPHj3Vnzyq/jk1+zJIy2zQt7lKJprpmWFuEHpF9yuEK8TD0SB58dRttaXdGsO",
	"hSkkc6iVxLcsYSXpEWRAikYYBjAiCMjWi3Acwj1U/11VTpwtoNbdz9yGqhs3vRxvjJ68mqxQR6MYJbWG",
	"3fCVMi/YLZW1Na26stZnpaV9oYGTVWDSjMqMeTmnY/ViQZFnyvT9Kfsltw3nxnzWPfnUWldz3greWEaJ",
	"jIniXCxZio6WKUfz+ujnRdqpLKrgBWQ0mFGwiVEkIQCxDr5F2RTUyd+5OR1z76ZhWlemI7ew+wxC4cv8",
	"O80D0WTmn8Ft8v2dB0m62YQIYq/B7VIhrfx6M0GX6FudFm6qbnAcpD7xGh09/L0kTrG/BzpkX56zUjJo",
	"gNEW4Tjy0HrDWdWzWlZsDSMCQisrK6kdJd4SQxgJ61h1Y31PblfrbOY3b3WN5RuIfUr4sq/tWdRTGAgL",
	"Y2LqdGCfm1PT0SfemT2fWxO2Uq4z9UGfC09zv8HcnrBS11a2lq67Zh8nwo7eghh5q+udUvfYrykm9Wu4",
	"DwhcxpmLs9J071qfuybTkJ0P9tQbW/Yna2x2N4Z/X6hc2pStzL7zwQbcoBAVaJQPVUHHdM6t6bk3c+wz",
	"a2J6hj5jGvxQfGSemY45Ncx56bE18wzdGeeWCevKqasb7sScz2uPWGBM9utM/8wrGZsf6j/OzLHnms6l",
	"NWUDwzEvbdf05q7uuN6cKkU7Iritw2/OLGpk6RmAuvZHc+qdO/ZCLLCYTmzjY/GDVHeqhSpwO2gPDaMw",
	"naT1Heo/DxCGPtnLzVkxVGtgtvO6R2kYghs6GxGcQglfbsM4xl4ItzCUO+LXYLkHzhbxO1WaOg3CfAkc",
	"Q/qbhCH54DavPHs6+UyH1GRxfs7s5bE1pz3PDPPF3LUvTYfizqXt2o7x2ZiY816DYrO6T5DP1tXbInYS",
	"Akhaokm/0q0JH4y7GLJc1qj9UXIB2AvXPrOdbEjPJvp0yh0Al/YVv6ISILpXmuxLkiYeZX6QZipHr16a",
	"s3LzvJiEE9zbH8DEx2iT+TUHiwj9mcLwXiuUkEQjK6iZV3NTu0NkhSJ2b8zsRNuEgFBo1f4GouCPKElv",
	"KIQBEuPiUfL3N4MunEzzRXvK8ZLYVsaUFD6/+XCThTY2eTQzx6J3A5dIbhrwF2DUYz2gVFmpqIy6czpz",
	"I7/uv5T6sHrGkcrDU7u8WYLrqXm89XcyPU8c6aFBoRdxiiXmJdwNDs8P4wRFy259rzagKNwKFcUbGB1c",
	"EYbLNATYW+UEt9XgZC9njaMSfAcjcn9Lb+G2ZOYWOmY15qFSQsa7DM8lGkhdI8qiMxwWHuI6+tSgSDex",
	"jdw1OjXda9v5SOGPQaEtLjva19MGq2gF0XIl9xw3TG6CH4+s0vVNBFBYKp9i1Fy6vnbaZKhV6qtHqqKA",
	"rA4ivIqBOBQVRf6+rLsOjFDJ14juVjBistAwR7eEsjxH9ECnk+MZVKfMvFxnJmq3RUltWa5x7WGMUq1e",
	"8vFb4Ldp9Re2a2aq89zVF44+zTzzZyaLsprQR/PFzHQudSfz2s+5lu6YhmNmIVW6Y+rMu+MuHFZuMTcX",
	"l1RrsT6a3vxCdzJ95cNizrRyqnLrnyyqpzNTzXX0y/zBpek6Nn3CBdx1dGsq3OuWwwnIY70mdkayM7Pt",
	"icd/HQwHZwtzIhS8ts6sXvpaU/DIj9JZc0u9E0r4tMDWbDvpKSA9V5gO8A/GdxE8pFwRiFpd+pjY03OP",
	"6dPX+mehS891R2cxeeU+pqawY12Z2cs2HRaOaWYLWmPToQbcdJwX/tIDjFv9mZXon+7K0psQJSu5H4Y/",
	"zCMrPBL3HkmzrCiL1XFpxZJBhWFIx1MR+tp/nMr36cijXEg/Rgha+QGDhYUD/y+O+oQhNHqAswAo3iFD",
	"WWxWHj9VjqvqVP4lm2BkHtAiymvPRZU8hmvPYnm394ovEl+WNdH2N6g5DCDfDVArxs3GXFx6rIfyEsI6",
	"unSJPyFgvenhKBa+LxbsamKP3V19dkDUqzlinkg3M/XhAi143O2eoIQ0t72fSy9jggxAj5Ip9fDCbniQ",
	"uAPG5kx3qIbItr7xfZA86H9qsqCX4uep7Xozez63uJuXe5zdzzPTK0e4tHiwjpjTHUFnvUSxobJj5k9X",
	"jFovvlQqOWp+NIZd9eOEsPRwtDxoC/boxQWhgiPmg3xRrw8DcsfBsbaczthXEMv3oe01cee1vKLJu9l3",
	"12doiPbgsXPgCRS7LvP4GNkzz/aAHzY+8sLH3/4nGB0CM17L4OCb7g8aG7sN+8fd+icYGc25C46WNfKN",
	"g73GRZ4y5Kjb/hSjImfEaxkUC76tbf8xwUoeccu54ph5sQ9jQbmKI+NFlplDFgwRelvQMyASRf3frtBa",
	"fEiopZFOI2e+LByGt6PPTkS48RL0v76dU137KtJgnE10t565ojkZxUEMyhomUt2y3l9bcKrxaYnjdOOh",
	"QJOvlCZJ2hDD/tw7x4eDLUpSEHqcD9JRXmtwKerliYO5hoM7CL8G4P6QbYrNoV+7ar9IG5RAvIXT+E6e",
	"k6xvFrHWbArw2wbhe7ZtuCHqyu9KUPPIHDaPyj4nkl8mdtiRDactX12jOfVzU8G9rHxunSlmuhK+PS5Z",
	"2yE5Qr7erfrNC53hHV1icXimtz55KCRRxgaPHzbsy9nEzNZqrOmVPrHGLMJ+Os7iado3Cx+Qh60zkVeR",
	"uauaNqUxa1clBQrttdouw7Kotybx4tySCzr5Eela98viJcnV2pnHS0jdJ9k/5ccBrW8HXBJ5K73jbXeu",
	"2D57oqmu4Xtf4X1bCsItCNM9Yq+yJl3RQtIw9D6srDa9SkvzBjnx6zWORoCkuGFzZQhQ5FXiKxqzMXal",
	"KWWfKVVarkJKORWA1hms95zThfGtGNxDc3g2taCmCPSc98ubH55ciXwhu0Pa9dM2uCTxpnFkdfZna6LS",
	"+g4CscuEojK6mjycj9RBQrjOs3zv4SE0s2LyEOJOreawIOPHpNoozOVe2UHXKNqzxKO1HZ7bAITEyzdw",
	"P0U8t1BtIwLJDd2Z/vkyy2BZbKLkSbDye54MK7/dOylWi3KUD8qObKbNYpKPT7nfxCtnt+8X21p2yEgj",
	"W8s797qlyBFLSB0hIqXNrXUqX6769O69+NajVrg0rv7Sno5ZmLK7MOfZ1bU5nubX7sXC4ZdnjpVdzHV3",
	"4fDLBSvdJ1w9R4ZGY6hROqgIZ+Ojp4eOFtg3Ixn45vW2nRim1FLwNL+Ooj3pp6rQ/hnV+tNPEa4//bic",
	"4TcfOeXcT2Lq2uz4gHlTzBuHwxa0bM7uVpeBw1JDdu+ugbcgDYn3ZEkBi5nPF1JSdE9/RQKLh2HhztzX",
	"m9maMaTP3uTm2e0HOEpBiBoyPHb5UIeDuxUiMORrYLvtHNf65zklrzj6gl959tnZxJqabMPeldlrGhNz",
	"flYmNd4lbQm5hSyheVNFqmWony9flR8MB99O4Dew3oT5mga7Pnk3OP3+8MCKhbH/tSUU76faQnW2ip4U",
	"wV/SYvfImNUYcNWkEAlugY692Uxtz19v+XbTahvkCXb2yePCU/JIptfedO8+20J922gSCf+9nA0o/2ae",
	"BGiX+4exuyDpi0Dvjs4HZkH5KUbknlqofLdYYSQzNjAIgAAzueJErwjZDFjx/FiZ8tZ9dwU1ewMjjTmu",
	"oDaj1GtWRCC+BT7U/mYbM+vvGozATQgTDWiJD9jWoaEGUhKvqdhq5pWGY7BG0VJLIEk32g0kd7Baqc03",
	"FCUaiAINXsYsVcm9Nod4i3yozXC8RQHEyRvNIlqSbjYxJolW8lkMtSy9rca4rNE20SkaxZEGv/krEC2h",
	"9jcU+WEaUGpCtIVaZtJqGcawj/9BgSlKgJ8V3NKR9Pei6iw9lYahH+OgqHaoYbiOCSwT4GeRyFmTyAru",
	"qIhvtWQNMDnJHXoa3+D1RyRSnXOK4h6CyZs/oj8id4USLdlAH92iTKK1IPZTqrdrKNFijJYoAmF4r92A",
	"BAZaHGm0m5PT0egGkZvU/wrJmxgvR8kKYAiiICN5FPvRSRQHcJRgf7QGCYF4lI/kUbyBEdigE/rdN/9N",
	"4kjTftc3wF9BbYJ8GCVwqHGp1d6/efvljcaGjjGzKqQiksDwlhIaZuUCDSSagSEgtDeMeL2Oo0TTCcHo",
	"JqVFTqbxGGK0ZS8k2q9v3mYDMALZrraidT6vxM/qYG3kH0lGN/cnUTD69c3bUQiXIOTzDH+c+e2YhDyG",
	"kkJaD6aILeATBgA9xO79m/cDEQ/oPd81CjZocDr45c3bN+/YtElWDBFGsb9BI/re6ffBErLZMNvJh+LI",
	"Cgang3NYhNqy6Raw1QoOWPQjKwgCBiGcYaVtUQMRMbPNgxkEy9D1y24WYsS9f/s2V0C5wv+P0T8EDK3j",
	"6TZ3we42pTwLwFZiNd7WIzF21QsBGAJAi3xom6iaY05YJWV0tj9mmj1Y0vbmdCcnTLWKwxDiwRf6QtHr",
	"dECKsfQBDGFmTpQHwZj9LsbNv5ixsD8be3BOYEuZecNGIXklzCntjXgMnzZ8VbDMqFmc/HhO/ZnChHyI",
	"g/sKk8BmE/JpaESnsP4cq3GpTNHDMfRPKuueVPXOC+idEkRj6EO0hXiUa4bcj5KMvvOVDit46AZvh1dT",
	"XXF+7j4eNtT46cTJuv6EBR08RYVGjJnSTDWzJ6qU6lUntzhen3CHxAlXFJ+yaubEOOFW+JNUS+JnopfE",
	"j6OWKp67Kovxe1Bdf6aQ5XPglVVWAV/GbNq0I7cbG3jJk1za++ohSs6VnL9qOS+Wc9rq6hF2q1CkRQtU",
	"KKJQ5HWgyDPZGJJg0B9sajwXKJSMjwRGgcz0yJK2jr6nKLM9mq391uy0Ck4UnPwsOEnRiwCSVvn4sZCS",
	"7cn8IfhRcV00qSFzVlwpIQo1lBLSP0n7MYNG4e1kq1MB353ZvJYQIhgR+y6CgRHgnsgAFDIoZHgEMjzX",
	"ssXYeaGyG+De4jr67gfYGj+0xRMooVVC+0KmczZYX4yfLweAp5FGHms2yo4YLp382z6ngsiHoSOEqisJ",
	"VRJ6vNNqbTj/YEddNftst4Rzyd1LyvlmTm9qX7eLt5ApRMm1kuujlWthHL9KgeZHWprzeeeMXdrFr4Ra",
	"CfXRCnVpJL9SsbZnfaV6l0BBCbUS6iMW6t1AfpUynZ8bbU+npuHaTrtcV7ePKtlWsn20sl0dzK9Jvouj",
	"9UbfeV8acQAfRt9ZB1jjh9H3/JX+Hu/iRAEl9krsf5rbezecn6A2Lg5PUNNOnF6KT353AEgntBRwUQuy",
	"BcRfSXQB+rNCBoUMChmeFxkO03pAcUzurJRspJacpPLDS1zBb4ampl2gCpYULClYeoGw1O+0siMCoaew",
	"vUbf4TaBi/5WGDsBUQGaAjQFaE8CaPLKuFC+FFsuO/b02e04hS0KWxS2vFhsUdbgY6xBBW4K3BS4vTJw",
	"6z4r/i9rT9LX+drmHrta1Nq+QkqFlC8VKZvYVcj5i9kQVA6reFarVWGWwiyFWX8lzFKG8GMMYYWXCi8V",
	"Xiq8fNTW1J8UNvscBjZPjNNiX+epc3qb0WrziwJYBbDteahejK1a2uDTCis5UhxoqCpUUKigUOHJUUFZ",
	"g4241G0MKkxSmKQw6YVgUnva7p+xDflRACQ3t7ID6VusrewFbmx1nOu2A7LsHHSFYwrHFI5VasoF6qUY",
	"XD1BhQNF72MMFRYoLFBYcGRYwEX1YDToYeIoNFBooNDgidHg6Q0cEQlemn0jBZ8G8yb+CtvWktjzPfb7",
	"ufR9BV4KvBR4VcGLS9JTHM3IXhPLBfAWpCEZnA6cM/YJGKVrCgX62LuwDW8xZyfu67NZfmm7F+w/e//L",
	"8IcqUQwjesAYw6YDV68UECkgUkD0WoBILZo1gGEPe1IBoQJCBYR/aSBsNWR32tgxYF5hxvITL8Xj6xrt",
	"0wAnZzhejwEBFBNVKLmCwx8Jh9WD9QGBHuXB4NDCJD6kaHx7m0AyeJLj+0O0RvtW9bwnek1Q8sgz9iqI",
	"MtqAJdydvN0CLjOwhApfFL4c8XnbRyKW+UEA3/nVQ5+T8fXkPvKL1OVKNJVo/jxLiI3a1ppyO0FymuRw",
	"IB4+NxyUT66i98KRN8NB7bQMiVHxoo/s35068HLP6G8/5kDArmKTV5sykScWpaipNAoFW8piea0Wiyjp",
	"T7BFVAY0PQ2YnBJlxSjMUVbMTxLVvgcc5bTYbKlKiasS15chrq/xQKH+EtsvLb65TaCSWyW3r0Bu/wJp",
	"6A+R/j2SmObvKUBQgKAA4S+aNFSGMfnm5Db04LurVVCDgg3lIny1LkIu5T3dDh1JDSQI09M/mION8g8q",
	"wFH+wZ8hp0JGx5G/AniJoqW3wfAWYhj5WXsaI8H5+zPhdSW3Sm5/lty+qCxFMuH4sWEGEgqKSKWnxBK+",
	"Jbhtns92NCubQkGFsilerU2RCXlPVaU9j0AdXXoaFBxolD2hwEbZEz9ORtlmqla5ZG8okVQiqeb/Vzv/",
	"UxnvCy09t1/yHEI9J3/2spr7FdCouf/Hyucul9coFyPYvnHKgSB00TojSq+InhJXJa4/R1xV3gaKGnl8",
	"o1NyXT6jq7IEAFZ0Gz8WorYQVyMdypW5K5RoMAo2MYqIFqKEJBoIQ42soAa2AIXgJoQaHWFaXpcGooA9",
	"96lUU8IDFC21hTNJNBJrdyuIYf6ylmygj26RrwWQABQmWpL6Kw0krIIk3WxiTGBQUJBoPoi0G6jdxmkU",
	"vBkM69rNVd6kfvioH4yPzxk4i5K8HT16OGd8pY8fhoME+ilG5J41nw2EwenvXyjlCcTbnC/lys9hRDkK",
	"Ay17R0txOBgO6N/TwYqQzemIBeGFqzghp/96+6+3g4cvD/8/AAD//+fsnaD+OwEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
